# 太上老君协同机制集成文档

## 文档概述

本文档详细描述了太上老君AI平台的协同机制集成方案，包括API规范、开发指南、部署说明和最佳实践。太上老君平台基于S×C×T三轴协同理念，通过"太上"智慧决策层和"老君"智能执行层的深度融合，实现高效的众包协作开发生态系统。

## 1. 系统架构总览

### 1.1 整体架构图

```mermaid
graph TB
    subgraph "太上老君协同生态系统"
        subgraph "太上系统 - 智慧决策层"
            TS[太上核心服务]
            TRM[需求管理模块]
            TAI[智能分析引擎]
            TDM[决策管理器]
            TQG[质量网关]
        end
        
        subgraph "老君系统 - 智能执行层"
            LJ[老君核心服务]
            LDE[开发环境]
            LCS[跨端同步]
            LCA[协作引擎]
            LAI[AI助手]
        end
        
        subgraph "三轴协调中心"
            SAxis[S轴 - 技术维度]
            CAxis[C轴 - 文化维度]
            TAxis[T轴 - 时间维度]
            CC[坐标计算器]
            AM[适应性管理]
        end
        
        subgraph "数据存储层"
            PDB[(项目数据库)]
            UDB[(用户数据库)]
            KDB[(知识图谱)]
            VDB[(向量数据库)]
            CDB[(缓存数据库)]
        end
        
        subgraph "外部集成"
            GH[GitHub]
            GL[GitLab]
            DC[Discord]
            SL[Slack]
            AI[外部AI服务]
        end
    end
    
    TS --> TRM
    TRM --> TAI
    TAI --> TDM
    TDM --> TQG
    TQG --> LJ
    
    LJ --> LDE
    LDE --> LCS
    LCS --> LCA
    LCA --> LAI
    
    TS <--> CC
    LJ <--> CC
    CC --> SAxis
    CC --> CAxis
    CC --> TAxis
    
    TS --> PDB
    TS --> UDB
    LJ --> PDB
    LJ --> KDB
    LAI --> VDB
    LCS --> CDB
    
    TS <--> GH
    LJ <--> GL
    LCA <--> DC
    LCA <--> SL
    TAI <--> AI
    LAI <--> AI
```

### 1.2 核心组件说明

#### 太上系统组件
- **太上核心服务 (TS)**: 系统总控制器，负责整体协调和决策
- **需求管理模块 (TRM)**: 需求收集、分析、分解和分发
- **智能分析引擎 (TAI)**: 基于AI的需求分析和预测
- **决策管理器 (TDM)**: 智能决策制定和优化
- **质量网关 (TQG)**: 质量控制和审核机制

#### 老君系统组件
- **老君核心服务 (LJ)**: 执行层总控制器
- **开发环境 (LDE)**: 多端统一开发环境
- **跨端同步 (LCS)**: 实时数据同步机制
- **协作引擎 (LCA)**: 实时协作和通信
- **AI助手 (LAI)**: 智能编程辅助

## 2. API规范文档

### 2.1 RESTful API 设计原则

```yaml
# API设计规范
api_version: "v1"
base_url: "https://api.taishanglaojun.dev/v1"
authentication: "Bearer Token + API Key"
rate_limiting: "1000 requests/hour per user"
response_format: "JSON"
error_handling: "RFC 7807 Problem Details"

# 通用响应格式
response_schema:
  success_response:
    type: object
    properties:
      success:
        type: boolean
        example: true
      data:
        type: object
      metadata:
        type: object
        properties:
          timestamp:
            type: string
            format: date-time
          request_id:
            type: string
          version:
            type: string
  
  error_response:
    type: object
    properties:
      success:
        type: boolean
        example: false
      error:
        type: object
        properties:
          code:
            type: string
          message:
            type: string
          details:
            type: object
      metadata:
        type: object
```

### 2.2 太上系统API

#### 2.2.1 需求管理API

```go
// 需求管理API实现
package api

import (
    "encoding/json"
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
    "github.com/taishanglaojun/core/models"
    "github.com/taishanglaojun/core/services"
)

type RequirementAPI struct {
    requirementService *services.RequirementService
    aiAnalyzer        *services.AIAnalyzer
    coordinateEngine  *services.CoordinateEngine
}

// CreateRequirement 创建新需求
// POST /api/v1/requirements
func (r *RequirementAPI) CreateRequirement(c *gin.Context) {
    var req models.CreateRequirementRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 智能需求分析
    analysis, err := r.aiAnalyzer.AnalyzeRequirement(req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "ANALYSIS_FAILED",
                "message": "Failed to analyze requirement",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 计算三轴坐标
    coordinate, err := r.coordinateEngine.CalculateCoordinate(analysis)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "COORDINATE_CALCULATION_FAILED",
                "message": "Failed to calculate coordinate",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 创建需求
    requirement := &models.Requirement{
        ID:          generateID(),
        Title:       req.Title,
        Description: req.Description,
        Priority:    analysis.Priority,
        Coordinate:  coordinate,
        Status:      "pending",
        CreatedBy:   req.UserID,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
        Analysis:    analysis,
    }
    
    if err := r.requirementService.CreateRequirement(requirement); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "CREATION_FAILED",
                "message": "Failed to create requirement",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusCreated, gin.H{
        "success": true,
        "data": gin.H{
            "requirement": requirement,
            "coordinate": coordinate,
            "analysis": analysis,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// GetRequirements 获取需求列表
// GET /api/v1/requirements
func (r *RequirementAPI) GetRequirements(c *gin.Context) {
    var query models.RequirementQuery
    if err := c.ShouldBindQuery(&query); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_QUERY",
                "message": "Invalid query parameters",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 应用三轴过滤
    if query.SAxis != nil || query.CAxis != nil || query.TAxis != nil {
        query.CoordinateFilter = &models.CoordinateFilter{
            SAxis: query.SAxis,
            CAxis: query.CAxis,
            TAxis: query.TAxis,
            Radius: query.Radius,
        }
    }
    
    requirements, total, err := r.requirementService.GetRequirements(query)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "QUERY_FAILED",
                "message": "Failed to query requirements",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "requirements": requirements,
            "pagination": gin.H{
                "total": total,
                "page": query.Page,
                "limit": query.Limit,
                "has_more": total > query.Page*query.Limit,
            },
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// UpdateRequirement 更新需求
// PUT /api/v1/requirements/:id
func (r *RequirementAPI) UpdateRequirement(c *gin.Context) {
    requirementID := c.Param("id")
    
    var req models.UpdateRequirementRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 获取现有需求
    existing, err := r.requirementService.GetRequirement(requirementID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            "success": false,
            "error": gin.H{
                "code": "REQUIREMENT_NOT_FOUND",
                "message": "Requirement not found",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 重新分析需求（如果内容有变化）
    if req.Title != nil || req.Description != nil {
        analysisReq := models.CreateRequirementRequest{
            Title:       getStringValue(req.Title, existing.Title),
            Description: getStringValue(req.Description, existing.Description),
            UserID:      req.UserID,
        }
        
        analysis, err := r.aiAnalyzer.AnalyzeRequirement(analysisReq)
        if err == nil {
            coordinate, err := r.coordinateEngine.CalculateCoordinate(analysis)
            if err == nil {
                existing.Coordinate = coordinate
                existing.Analysis = analysis
            }
        }
    }
    
    // 更新字段
    if req.Title != nil {
        existing.Title = *req.Title
    }
    if req.Description != nil {
        existing.Description = *req.Description
    }
    if req.Priority != nil {
        existing.Priority = *req.Priority
    }
    if req.Status != nil {
        existing.Status = *req.Status
    }
    
    existing.UpdatedAt = time.Now()
    
    if err := r.requirementService.UpdateRequirement(existing); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "UPDATE_FAILED",
                "message": "Failed to update requirement",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "requirement": existing,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// AssignRequirement 分配需求
// POST /api/v1/requirements/:id/assign
func (r *RequirementAPI) AssignRequirement(c *gin.Context) {
    requirementID := c.Param("id")
    
    var req models.AssignRequirementRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 智能匹配开发者
    if req.AutoAssign {
        developers, err := r.requirementService.FindMatchingDevelopers(requirementID)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                "success": false,
                "error": gin.H{
                    "code": "MATCHING_FAILED",
                    "message": "Failed to find matching developers",
                    "details": err.Error(),
                },
            })
            return
        }
        
        if len(developers) > 0 {
            req.AssigneeID = developers[0].ID
        }
    }
    
    assignment, err := r.requirementService.AssignRequirement(requirementID, req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "ASSIGNMENT_FAILED",
                "message": "Failed to assign requirement",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "assignment": assignment,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}
```

#### 2.2.2 三轴坐标API

```go
// 三轴坐标API实现
package api

import (
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
    "github.com/taishanglaojun/core/models"
    "github.com/taishanglaojun/core/services"
)

type CoordinateAPI struct {
    coordinateService *services.CoordinateService
    aiEngine         *services.AIEngine
}

// CalculateCoordinate 计算三轴坐标
// POST /api/v1/coordinates/calculate
func (co *CoordinateAPI) CalculateCoordinate(c *gin.Context) {
    var req models.CoordinateCalculationRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // S轴分析 - 技术复杂度
    sAxisScore, sAxisDetails, err := co.coordinateService.AnalyzeTechnicalComplexity(req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "S_AXIS_ANALYSIS_FAILED",
                "message": "Failed to analyze technical complexity",
                "details": err.Error(),
            },
        })
        return
    }
    
    // C轴分析 - 文化影响
    cAxisScore, cAxisDetails, err := co.coordinateService.AnalyzeCulturalImpact(req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "C_AXIS_ANALYSIS_FAILED",
                "message": "Failed to analyze cultural impact",
                "details": err.Error(),
            },
        })
        return
    }
    
    // T轴分析 - 时间敏感度
    tAxisScore, tAxisDetails, err := co.coordinateService.AnalyzeTimeSensitivity(req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "T_AXIS_ANALYSIS_FAILED",
                "message": "Failed to analyze time sensitivity",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 构建坐标
    coordinate := &models.ThreeAxisCoordinate{
        S: models.AxisValue{
            Score:      sAxisScore,
            Confidence: sAxisDetails.Confidence,
            Details:    sAxisDetails,
        },
        C: models.AxisValue{
            Score:      cAxisScore,
            Confidence: cAxisDetails.Confidence,
            Details:    cAxisDetails,
        },
        T: models.AxisValue{
            Score:      tAxisScore,
            Confidence: tAxisDetails.Confidence,
            Details:    tAxisDetails,
        },
        CalculatedAt: time.Now(),
        Version:     "v1.0",
    }
    
    // 坐标优化
    optimizedCoordinate, err := co.coordinateService.OptimizeCoordinate(coordinate)
    if err != nil {
        // 优化失败不影响主流程，使用原始坐标
        optimizedCoordinate = coordinate
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "coordinate": optimizedCoordinate,
            "analysis": gin.H{
                "s_axis": sAxisDetails,
                "c_axis": cAxisDetails,
                "t_axis": tAxisDetails,
            },
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// FindSimilarCoordinates 查找相似坐标
// POST /api/v1/coordinates/similar
func (co *CoordinateAPI) FindSimilarCoordinates(c *gin.Context) {
    var req models.SimilarCoordinateRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    similarCoordinates, err := co.coordinateService.FindSimilarCoordinates(req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "SEARCH_FAILED",
                "message": "Failed to find similar coordinates",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "similar_coordinates": similarCoordinates,
            "total": len(similarCoordinates),
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// GetCoordinateInsights 获取坐标洞察
// GET /api/v1/coordinates/:id/insights
func (co *CoordinateAPI) GetCoordinateInsights(c *gin.Context) {
    coordinateID := c.Param("id")
    
    insights, err := co.coordinateService.GetCoordinateInsights(coordinateID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INSIGHTS_FAILED",
                "message": "Failed to get coordinate insights",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "insights": insights,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}
```

### 2.3 老君系统API

#### 2.3.1 项目管理API

```go
// 项目管理API实现
package api

import (
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
    "github.com/taishanglaojun/laojun/models"
    "github.com/taishanglaojun/laojun/services"
)

type ProjectAPI struct {
    projectService *services.ProjectService
    syncEngine     *services.SyncEngine
    deviceManager  *services.DeviceManager
}

// CreateProject 创建项目
// POST /api/v1/projects
func (p *ProjectAPI) CreateProject(c *gin.Context) {
    var req models.CreateProjectRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 验证三轴坐标
    if err := p.validateCoordinate(req.Coordinate); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_COORDINATE",
                "message": "Invalid three-axis coordinate",
                "details": err.Error(),
            },
        })
        return
    }
    
    project, err := p.projectService.CreateProject(req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "CREATION_FAILED",
                "message": "Failed to create project",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 初始化项目同步
    if err := p.syncEngine.InitializeProjectSync(project.ID); err != nil {
        // 同步初始化失败不影响项目创建
        // 记录日志但继续执行
    }
    
    c.JSON(http.StatusCreated, gin.H{
        "success": true,
        "data": gin.H{
            "project": project,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// OpenProject 打开项目
// POST /api/v1/projects/:id/open
func (p *ProjectAPI) OpenProject(c *gin.Context) {
    projectID := c.Param("id")
    
    var req models.OpenProjectRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 获取设备信息
    deviceInfo, err := p.deviceManager.GetDeviceInfo(req.DeviceID)
    if err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_DEVICE",
                "message": "Invalid device ID",
                "details": err.Error(),
            },
        })
        return
    }
    
    project, err := p.projectService.OpenProject(projectID, req.DeviceID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "OPEN_FAILED",
                "message": "Failed to open project",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 启动设备特定的同步
    syncConfig := p.generateSyncConfig(deviceInfo)
    if err := p.syncEngine.StartDeviceSync(projectID, req.DeviceID, syncConfig); err != nil {
        // 同步启动失败不影响项目打开
        // 记录日志但继续执行
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "project": project,
            "device_config": project.DeviceSettings[deviceInfo.Type],
            "sync_status": "initializing",
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// SyncProjectFile 同步项目文件
// PUT /api/v1/projects/:id/files/*filepath
func (p *ProjectAPI) SyncProjectFile(c *gin.Context) {
    projectID := c.Param("id")
    filePath := c.Param("filepath")
    
    var req models.SyncFileRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 验证文件内容
    if err := p.validateFileContent(filePath, req.Content); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_CONTENT",
                "message": "Invalid file content",
                "details": err.Error(),
            },
        })
        return
    }
    
    syncResult, err := p.projectService.SyncProjectFile(projectID, filePath, req.Content, req.DeviceID)
    if err != nil {
        // 检查是否是冲突错误
        if isConflictError(err) {
            c.JSON(http.StatusConflict, gin.H{
                "success": false,
                "error": gin.H{
                    "code": "FILE_CONFLICT",
                    "message": "File conflict detected",
                    "details": err.Error(),
                },
                "data": gin.H{
                    "conflict_info": extractConflictInfo(err),
                },
            })
            return
        }
        
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "SYNC_FAILED",
                "message": "Failed to sync file",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "sync_result": syncResult,
            "file_hash": syncResult.Hash,
            "sync_timestamp": syncResult.Timestamp,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// GetProjectFiles 获取项目文件列表
// GET /api/v1/projects/:id/files
func (p *ProjectAPI) GetProjectFiles(c *gin.Context) {
    projectID := c.Param("id")
    deviceID := c.Query("device_id")
    
    files, err := p.projectService.GetProjectFiles(projectID, deviceID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "QUERY_FAILED",
                "message": "Failed to get project files",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "files": files,
            "total": len(files),
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}
```

#### 2.3.2 实时协作API

```go
// 实时协作API实现
package api

import (
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
    "github.com/gorilla/websocket"
    "github.com/taishanglaojun/laojun/models"
    "github.com/taishanglaojun/laojun/services"
)

type CollaborationAPI struct {
    collaborationService *services.CollaborationService
    websocketUpgrader   websocket.Upgrader
}

// JoinCollaboration 加入协作会话
// GET /api/v1/collaboration/:project_id/join
func (co *CollaborationAPI) JoinCollaboration(c *gin.Context) {
    projectID := c.Param("project_id")
    userID := c.Query("user_id")
    deviceID := c.Query("device_id")
    
    if userID == "" || deviceID == "" {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "MISSING_PARAMETERS",
                "message": "user_id and device_id are required",
            },
        })
        return
    }
    
    // 升级到WebSocket连接
    conn, err := co.websocketUpgrader.Upgrade(c.Writer, c.Request, nil)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "WEBSOCKET_UPGRADE_FAILED",
                "message": "Failed to upgrade to WebSocket",
                "details": err.Error(),
            },
        })
        return
    }
    
    // 注册协作会话
    session := &models.CollaborationSession{
        ProjectID: projectID,
        UserID:    userID,
        DeviceID:  deviceID,
        Connection: conn,
        JoinedAt:  time.Now(),
    }
    
    if err := co.collaborationService.JoinSession(session); err != nil {
        conn.Close()
        return
    }
    
    // 启动消息处理
    go co.handleCollaborationMessages(session)
}

// SendCollaborationMessage 发送协作消息
// POST /api/v1/collaboration/:project_id/message
func (co *CollaborationAPI) SendCollaborationMessage(c *gin.Context) {
    projectID := c.Param("project_id")
    
    var req models.CollaborationMessageRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_REQUEST",
                "message": "Invalid request format",
                "details": err.Error(),
            },
        })
        return
    }
    
    message := &models.CollaborationMessage{
        ID:        generateMessageID(),
        ProjectID: projectID,
        UserID:    req.UserID,
        DeviceID:  req.DeviceID,
        Type:      req.Type,
        Content:   req.Content,
        Timestamp: time.Now(),
    }
    
    if err := co.collaborationService.BroadcastMessage(message); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "BROADCAST_FAILED",
                "message": "Failed to broadcast message",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "message_id": message.ID,
            "timestamp": message.Timestamp,
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

// GetCollaborationHistory 获取协作历史
// GET /api/v1/collaboration/:project_id/history
func (co *CollaborationAPI) GetCollaborationHistory(c *gin.Context) {
    projectID := c.Param("project_id")
    
    var query models.CollaborationHistoryQuery
    if err := c.ShouldBindQuery(&query); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "success": false,
            "error": gin.H{
                "code": "INVALID_QUERY",
                "message": "Invalid query parameters",
                "details": err.Error(),
            },
        })
        return
    }
    
    history, total, err := co.collaborationService.GetCollaborationHistory(projectID, query)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "success": false,
            "error": gin.H{
                "code": "QUERY_FAILED",
                "message": "Failed to get collaboration history",
                "details": err.Error(),
            },
        })
        return
    }
    
    c.JSON(http.StatusOK, gin.H{
        "success": true,
        "data": gin.H{
            "history": history,
            "pagination": gin.H{
                "total": total,
                "page": query.Page,
                "limit": query.Limit,
            },
        },
        "metadata": gin.H{
            "timestamp": time.Now(),
            "request_id": c.GetString("request_id"),
            "version": "v1",
        },
    })
}

func (co *CollaborationAPI) handleCollaborationMessages(session *models.CollaborationSession) {
    defer session.Connection.Close()
    
    for {
        var message models.CollaborationMessage
        if err := session.Connection.ReadJSON(&message); err != nil {
            break
        }
        
        // 处理不同类型的消息
        switch message.Type {
        case "cursor_update":
            co.handleCursorUpdate(session, &message)
        case "selection_update":
            co.handleSelectionUpdate(session, &message)
        case "text_change":
            co.handleTextChange(session, &message)
        case "voice_chat":
            co.handleVoiceChat(session, &message)
        default:
            co.handleGenericMessage(session, &message)
        }
    }
    
    // 清理会话
    co.collaborationService.LeaveSession(session)
}
```

## 3. 开发指南

### 3.1 快速开始

#### 3.1.1 环境准备

```bash
# 1. 克隆项目
git clone https://github.com/taishanglaojun/platform.git
cd platform

# 2. 安装依赖
# 后端依赖 (Go)
go mod download

# 前端依赖 (Node.js)
cd frontend
npm install

# 移动端依赖 (React Native)
cd ../mobile
npm install
cd ios && pod install && cd ..

# 3. 配置环境变量
cp .env.example .env
# 编辑 .env 文件，配置数据库、Redis、AI服务等

# 4. 初始化数据库
make db-migrate

# 5. 启动服务
make dev
```

#### 3.1.2 项目结构

```
taishanglaojun/
├── backend/                 # 后端服务
│   ├── taishang/           # 太上系统
│   │   ├── api/            # API接口
│   │   ├── services/       # 业务服务
│   │   ├── models/         # 数据模型
│   │   └── ai/             # AI引擎
│   ├── laojun/             # 老君系统
│   │   ├── api/            # API接口
│   │   ├── services/       # 业务服务
│   │   ├── sync/           # 同步引擎
│   │   └── collaboration/  # 协作引擎
│   └── shared/             # 共享组件
│       ├── models/         # 共享模型
│       ├── utils/          # 工具函数
│       └── middleware/     # 中间件
├── frontend/               # Web前端
│   ├── src/
│   │   ├── components/     # 组件
│   │   ├── pages/          # 页面
│   │   ├── services/       # API服务
│   │   └── utils/          # 工具函数
│   └── public/
├── mobile/                 # 移动端应用
│   ├── src/
│   │   ├── components/     # 组件
│   │   ├── screens/        # 屏幕
│   │   ├── services/       # API服务
│   │   └── utils/          # 工具函数
│   ├── ios/                # iOS特定代码
│   └── android/            # Android特定代码
├── watch/                  # 手表端应用
│   ├── WatchApp/           # 主应用
│   └── WatchExtension/     # 扩展
├── docs/                   # 文档
├── scripts/                # 脚本
└── docker/                 # Docker配置
```

### 3.2 核心概念

#### 3.2.1 三轴坐标系统

```python
# 三轴坐标系统示例
from dataclasses import dataclass
from typing import Dict, Any, Optional

@dataclass
class AxisValue:
    """轴值定义"""
    score: float        # 0-100的分数
    confidence: float   # 0-1的置信度
    details: Dict[str, Any]  # 详细分析结果

@dataclass
class ThreeAxisCoordinate:
    """三轴坐标"""
    s: AxisValue  # S轴 - 技术复杂度
    c: AxisValue  # C轴 - 文化影响度
    t: AxisValue  # T轴 - 时间敏感度
    
    def distance_to(self, other: 'ThreeAxisCoordinate') -> float:
        """计算到另一个坐标的距离"""
        s_diff = (self.s.score - other.s.score) ** 2
        c_diff = (self.c.score - other.c.score) ** 2
        t_diff = (self.t.score - other.t.score) ** 2
        return (s_diff + c_diff + t_diff) ** 0.5
    
    def is_similar_to(self, other: 'ThreeAxisCoordinate', threshold: float = 20.0) -> bool:
        """判断是否与另一个坐标相似"""
        return self.distance_to(other) <= threshold

# 使用示例
def create_requirement_coordinate(requirement_text: str) -> ThreeAxisCoordinate:
    """为需求创建三轴坐标"""
    
    # S轴分析 - 技术复杂度
    s_analysis = analyze_technical_complexity(requirement_text)
    s_axis = AxisValue(
        score=s_analysis['complexity_score'],
        confidence=s_analysis['confidence'],
        details=s_analysis
    )
    
    # C轴分析 - 文化影响度
    c_analysis = analyze_cultural_impact(requirement_text)
    c_axis = AxisValue(
        score=c_analysis['impact_score'],
        confidence=c_analysis['confidence'],
        details=c_analysis
    )
    
    # T轴分析 - 时间敏感度
    t_analysis = analyze_time_sensitivity(requirement_text)
    t_axis = AxisValue(
        score=t_analysis['urgency_score'],
        confidence=t_analysis['confidence'],
        details=t_analysis
    )
    
    return ThreeAxisCoordinate(s=s_axis, c=c_axis, t=t_axis)
```

#### 3.2.2 智能匹配算法

```python
# 智能匹配算法实现
import numpy as np
from typing import List, Tuple
from sklearn.metrics.pairwise import cosine_similarity

class IntelligentMatcher:
    """智能匹配器"""
    
    def __init__(self):
        self.weight_s = 0.4  # S轴权重
        self.weight_c = 0.3  # C轴权重
        self.weight_t = 0.3  # T轴权重
    
    def match_developers_to_requirement(
        self, 
        requirement: ThreeAxisCoordinate,
        developers: List[Tuple[str, ThreeAxisCoordinate, Dict]]
    ) -> List[Tuple[str, float, Dict]]:
        """为需求匹配开发者"""
        
        matches = []
        
        for dev_id, dev_coordinate, dev_profile in developers:
            # 计算匹配分数
            match_score = self.calculate_match_score(requirement, dev_coordinate, dev_profile)
            
            # 计算匹配详情
            match_details = self.calculate_match_details(requirement, dev_coordinate, dev_profile)
            
            matches.append((dev_id, match_score, match_details))
        
        # 按匹配分数排序
        matches.sort(key=lambda x: x[1], reverse=True)
        
        return matches
    
    def calculate_match_score(
        self, 
        requirement: ThreeAxisCoordinate,
        developer: ThreeAxisCoordinate,
        dev_profile: Dict
    ) -> float:
        """计算匹配分数"""
        
        # 基础坐标匹配
        coordinate_score = self.calculate_coordinate_match(requirement, developer)
        
        # 技能匹配
        skill_score = self.calculate_skill_match(requirement, dev_profile)
        
        # 经验匹配
        experience_score = self.calculate_experience_match(requirement, dev_profile)
        
        # 可用性匹配
        availability_score = self.calculate_availability_match(requirement, dev_profile)
        
        # 综合评分
        total_score = (
            coordinate_score * 0.4 +
            skill_score * 0.3 +
            experience_score * 0.2 +
            availability_score * 0.1
        )
        
        return min(100.0, max(0.0, total_score))
    
    def calculate_coordinate_match(
        self, 
        requirement: ThreeAxisCoordinate,
        developer: ThreeAxisCoordinate
    ) -> float:
        """计算坐标匹配度"""
        
        # S轴匹配 - 技术能力是否匹配技术复杂度
        s_match = self.calculate_axis_match(
            requirement.s.score, 
            developer.s.score, 
            match_type='capability'
        )
        
        # C轴匹配 - 文化理解是否匹配文化影响
        c_match = self.calculate_axis_match(
            requirement.c.score, 
            developer.c.score, 
            match_type='understanding'
        )
        
        # T轴匹配 - 时间偏好是否匹配时间敏感度
        t_match = self.calculate_axis_match(
            requirement.t.score, 
            developer.t.score, 
            match_type='preference'
        )
        
        return (
            s_match * self.weight_s +
            c_match * self.weight_c +
            t_match * self.weight_t
        )
    
    def calculate_axis_match(self, req_score: float, dev_score: float, match_type: str) -> float:
        """计算单轴匹配度"""
        
        if match_type == 'capability':
            # 能力匹配：开发者能力应该大于等于需求复杂度
            if dev_score >= req_score:
                return 100.0 - abs(dev_score - req_score) * 0.5  # 轻微惩罚过度匹配
            else:
                return max(0.0, 100.0 - (req_score - dev_score) * 2.0)  # 重度惩罚能力不足
                
        elif match_type == 'understanding':
            # 理解匹配：文化理解度应该匹配文化影响度
            diff = abs(req_score - dev_score)
            return max(0.0, 100.0 - diff * 1.5)
            
        elif match_type == 'preference':
            # 偏好匹配：时间偏好应该匹配时间敏感度
            diff = abs(req_score - dev_score)
            return max(0.0, 100.0 - diff * 1.0)
            
        else:
            # 默认匹配：越接近越好
            diff = abs(req_score - dev_score)
            return max(0.0, 100.0 - diff)
```

### 3.3 开发最佳实践

#### 3.3.1 API开发规范

```go
// API开发最佳实践示例
package api

import (
    "context"
    "net/http"
    "time"
    "github.com/gin-gonic/gin"
    "github.com/go-playground/validator/v10"
)

// 1. 统一的请求验证
type BaseRequest struct {
    RequestID string `json:"request_id" validate:"required,uuid"`
    Timestamp int64  `json:"timestamp" validate:"required"`
    Version   string `json:"version" validate:"required,oneof=v1 v2"`
}

// 2. 统一的响应格式
type BaseResponse struct {
    Success   bool        `json:"success"`
    Data      interface{} `json:"data,omitempty"`
    Error     *APIError   `json:"error,omitempty"`
    Metadata  *Metadata   `json:"metadata"`
}

type APIError struct {
    Code    string      `json:"code"`
    Message string      `json:"message"`
    Details interface{} `json:"details,omitempty"`
}

type Metadata struct {
    Timestamp time.Time `json:"timestamp"`
    RequestID string    `json:"request_id"`
    Version   string    `json:"version"`
    Duration  string    `json:"duration,omitempty"`
}

// 3. 中间件示例
func RequestValidationMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        // 生成请求ID
        requestID := generateRequestID()
        c.Set("request_id", requestID)
        c.Set("start_time", start)
        
        // 验证请求头
        if err := validateHeaders(c); err != nil {
            c.JSON(http.StatusBadRequest, BaseResponse{
                Success: false,
                Error: &APIError{
                    Code:    "INVALID_HEADERS",
                    Message: "Invalid request headers",
                    Details: err.Error(),
                },
                Metadata: &Metadata{
                    Timestamp: time.Now(),
                    RequestID: requestID,
                    Version:   "v1",
                },
            })
            c.Abort()
            return
        }
        
        c.Next()
        
        // 记录响应时间
        duration := time.Since(start)
        c.Header("X-Response-Time", duration.String())
    }
}

// 4. 错误处理
func HandleError(c *gin.Context, err error, code string, message string) {
    requestID := c.GetString("request_id")
    
    response := BaseResponse{
        Success: false,
        Error: &APIError{
            Code:    code,
            Message: message,
            Details: err.Error(),
        },
        Metadata: &Metadata{
            Timestamp: time.Now(),
            RequestID: requestID,
            Version:   "v1",
        },
    }
    
    // 根据错误类型返回不同的HTTP状态码
    statusCode := getHTTPStatusFromError(err)
    c.JSON(statusCode, response)
}

// 5. 成功响应
func HandleSuccess(c *gin.Context, data interface{}) {
    requestID := c.GetString("request_id")
    startTime := c.GetTime("start_time")
    
    response := BaseResponse{
        Success: true,
        Data:    data,
        Metadata: &Metadata{
            Timestamp: time.Now(),
            RequestID: requestID,
            Version:   "v1",
            Duration:  time.Since(startTime).String(),
        },
    }
    
    c.JSON(http.StatusOK, response)
}
```

#### 3.3.2 前端开发规范

```typescript
// 前端开发最佳实践示例
import { useState, useEffect, useCallback } from 'react';
import { ApiClient } from '../services/api';
import { ThreeAxisCoordinate, Requirement } from '../types';

// 1. 自定义Hook示例
export const useRequirements = (filters?: RequirementFilters) => {
    const [requirements, setRequirements] = useState<Requirement[]>([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [pagination, setPagination] = useState({
        page: 1,
        limit: 20,
        total: 0,
        hasMore: false
    });
    
    const fetchRequirements = useCallback(async (page = 1) => {
        setLoading(true);
        setError(null);
        
        try {
            const response = await ApiClient.getRequirements({
                ...filters,
                page,
                limit: pagination.limit
            });
            
            if (response.success) {
                if (page === 1) {
                    setRequirements(response.data.requirements);
                } else {
                    setRequirements(prev => [...prev, ...response.data.requirements]);
                }
                
                setPagination({
                    page,
                    limit: pagination.limit,
                    total: response.data.pagination.total,
                    hasMore: response.data.pagination.has_more
                });
            } else {
                setError(response.error?.message || 'Failed to fetch requirements');
            }
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Unknown error');
        } finally {
            setLoading(false);
        }
    }, [filters, pagination.limit]);
    
    const loadMore = useCallback(() => {
        if (!loading && pagination.hasMore) {
            fetchRequirements(pagination.page + 1);
        }
    }, [loading, pagination.hasMore, pagination.page, fetchRequirements]);
    
    const refresh = useCallback(() => {
        fetchRequirements(1);
    }, [fetchRequirements]);
    
    useEffect(() => {
        fetchRequirements(1);
    }, [fetchRequirements]);
    
    return {
        requirements,
        loading,
        error,
        pagination,
        loadMore,
        refresh
    };
};

// 2. 组件最佳实践
interface RequirementCardProps {
    requirement: Requirement;
    onSelect?: (requirement: Requirement) => void;
    onCoordinateClick?: (coordinate: ThreeAxisCoordinate) => void;
    className?: string;
}

export const RequirementCard: React.FC<RequirementCardProps> = ({
    requirement,
    onSelect,
    onCoordinateClick,
    className = ''
}) => {
    const handleCardClick = useCallback(() => {
        onSelect?.(requirement);
    }, [requirement, onSelect]);
    
    const handleCoordinateClick = useCallback((e: React.MouseEvent) => {
        e.stopPropagation();
        onCoordinateClick?.(requirement.coordinate);
    }, [requirement.coordinate, onCoordinateClick]);
    
    return (
        <div 
            className={`requirement-card ${className}`}
            onClick={handleCardClick}
            role="button"
            tabIndex={0}
            onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    handleCardClick();
                }
            }}
        >
            <div className="requirement-header">
                <h3 className="requirement-title">{requirement.title}</h3>
                <span className={`requirement-status status-${requirement.status}`}>
                    {requirement.status}
                </span>
            </div>
            
            <p className="requirement-description">
                {requirement.description}
            </p>
            
            <div className="requirement-coordinate" onClick={handleCoordinateClick}>
                <CoordinateVisualization coordinate={requirement.coordinate} />
            </div>
            
            <div className="requirement-footer">
                <span className="requirement-priority priority-{requirement.priority}">
                    {requirement.priority}
                </span>
                <span className="requirement-created">
                    {formatDate(requirement.created_at)}
                </span>
            </div>
        </div>
    );
};

// 3. API服务封装
class RequirementService {
    private apiClient: ApiClient;
    
    constructor(apiClient: ApiClient) {
        this.apiClient = apiClient;
    }
    
    async createRequirement(data: CreateRequirementRequest): Promise<Requirement> {
        const response = await this.apiClient.post<{requirement: Requirement}>(
            '/requirements',
            data
        );
        
        if (!response.success) {
            throw new Error(response.error?.message || 'Failed to create requirement');
        }
        
        return response.data.requirement;
    }
    
    async getRequirements(filters: RequirementFilters): Promise<{
        requirements: Requirement[];
        pagination: PaginationInfo;
    }> {
        const response = await this.apiClient.get<{
            requirements: Requirement[];
            pagination: PaginationInfo;
        }>('/requirements', { params: filters });
        
        if (!response.success) {
            throw new Error(response.error?.message || 'Failed to fetch requirements');
        }
        
        return response.data;
    }
    
    async updateRequirement(
        id: string, 
        data: UpdateRequirementRequest
    ): Promise<Requirement> {
        const response = await this.apiClient.put<{requirement: Requirement}>(
            `/requirements/${id}`,
            data
        );
        
        if (!response.success) {
            throw new Error(response.error?.message || 'Failed to update requirement');
        }
        
        return response.data.requirement;
    }
}

// 4. 错误边界组件
interface ErrorBoundaryState {
    hasError: boolean;
    error?: Error;
}

export class ErrorBoundary extends React.Component<
    React.PropsWithChildren<{}>,
    ErrorBoundaryState
> {
    constructor(props: React.PropsWithChildren<{}>) {
        super(props);
        this.state = { hasError: false };
    }
    
    static getDerivedStateFromError(error: Error): ErrorBoundaryState {
        return { hasError: true, error };
    }
    
    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
        console.error('Error caught by boundary:', error, errorInfo);
        
        // 发送错误报告
        this.reportError(error, errorInfo);
    }
    
    private reportError(error: Error, errorInfo: React.ErrorInfo) {
        // 发送到错误监控服务
        // 例如：Sentry, LogRocket等
    }
    
    render() {
        if (this.state.hasError) {
            return (
                <div className="error-boundary">
                    <h2>Something went wrong</h2>
                    <p>We're sorry, but something unexpected happened.</p>
                    <button onClick={() => window.location.reload()}>
                        Reload Page
                    </button>
                </div>
            );
        }
        
        return this.props.children;
    }
}
```

## 4. 部署指南

### 4.1 Docker部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 太上系统服务
  taishang-api:
    build:
      context: ./backend/taishang
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/taishang
      - REDIS_URL=redis://redis:6379
      - AI_SERVICE_URL=http://ai-service:8000
    depends_on:
      - postgres
      - redis
      - ai-service
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    
  # 老君系统服务
  laojun-api:
    build:
      context: ./backend/laojun
      dockerfile: Dockerfile
    ports:
      - "8081:8081"
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/laojun
      - REDIS_URL=redis://redis:6379
      - TAISHANG_API_URL=http://taishang-api:8080
    depends_on:
      - postgres
      - redis
      - taishang-api
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped
    
  # Web前端
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_URL=http://localhost:8080
      - REACT_APP_LAOJUN_API_URL=http://localhost:8081
    depends_on:
      - taishang-api
      - laojun-api
    restart: unless-stopped
    
  # AI服务
  ai-service:
    image: ollama/ollama:latest
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    environment:
      - OLLAMA_HOST=0.0.0.0
    restart: unless-stopped
    
  # 数据库
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_DB=taishanglaojun
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped
    
  # Redis缓存
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    
  # 向量数据库
  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"
    volumes:
      - qdrant_data:/qdrant/storage
    restart: unless-stopped
    
  # 消息队列
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=password
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    restart: unless-stopped
    
  # 监控服务
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    restart: unless-stopped
    
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana:/etc/grafana/provisioning
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  qdrant_data:
  rabbitmq_data:
  prometheus_data:
  grafana_data:
  ollama_data:
```

### 4.2 Kubernetes部署

```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: taishanglaojun
  labels:
    name: taishanglaojun

---
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: taishang-config
  namespace: taishanglaojun
data:
  DATABASE_URL: "postgresql://user:password@postgres:5432/taishang"
  REDIS_URL: "redis://redis:6379"
  AI_SERVICE_URL: "http://ai-service:8000"
  LOG_LEVEL: "info"

---
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: taishang-secrets
  namespace: taishanglaojun
type: Opaque
data:
  db-password: cGFzc3dvcmQ=  # base64 encoded 'password'
  jwt-secret: c2VjcmV0a2V5  # base64 encoded 'secretkey'
  ai-api-key: YWlfa2V5XzEyMw==  # base64 encoded 'ai_key_123'

---
# k8s/taishang-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: taishang-api
  namespace: taishanglaojun
spec:
  replicas: 3
  selector:
    matchLabels:
      app: taishang-api
  template:
    metadata:
      labels:
        app: taishang-api
    spec:
      containers:
      - name: taishang-api
        image: taishanglaojun/taishang-api:latest
        ports:
        - containerPort: 8080
        envFrom:
        - configMapRef:
            name: taishang-config
        - secretRef:
            name: taishang-secrets
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5

---
# k8s/taishang-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: taishang-api
  namespace: taishanglaojun
spec:
  selector:
    app: taishang-api
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP

---
# k8s/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: taishang-ingress
  namespace: taishanglaojun
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/rate-limit: "100"
spec:
  tls:
  - hosts:
    - api.taishanglaojun.dev
    secretName: taishang-tls
  rules:
  - host: api.taishanglaojun.dev
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: taishang-api
            port:
              number: 8080
```

### 4.3 生产环境配置

```bash
#!/bin/bash
# scripts/deploy-production.sh

set -e

echo "开始生产环境部署..."

# 1. 环境检查
echo "检查环境依赖..."
command -v docker >/dev/null 2>&1 || { echo "Docker未安装" >&2; exit 1; }
command -v kubectl >/dev/null 2>&1 || { echo "kubectl未安装" >&2; exit 1; }

# 2. 构建镜像
echo "构建Docker镜像..."
docker build -t taishanglaojun/taishang-api:${VERSION} ./backend/taishang
docker build -t taishanglaojun/laojun-api:${VERSION} ./backend/laojun
docker build -t taishanglaojun/frontend:${VERSION} ./frontend

# 3. 推送镜像
echo "推送镜像到仓库..."
docker push taishanglaojun/taishang-api:${VERSION}
docker push taishanglaojun/laojun-api:${VERSION}
docker push taishanglaojun/frontend:${VERSION}

# 4. 更新Kubernetes配置
echo "更新Kubernetes配置..."
sed -i "s/latest/${VERSION}/g" k8s/*.yaml

# 5. 应用配置
echo "应用Kubernetes配置..."
kubectl apply -f k8s/

# 6. 等待部署完成
echo "等待部署完成..."
kubectl rollout status deployment/taishang-api -n taishanglaojun
kubectl rollout status deployment/laojun-api -n taishanglaojun
kubectl rollout status deployment/frontend -n taishanglaojun

# 7. 健康检查
echo "执行健康检查..."
./scripts/health-check.sh

echo "生产环境部署完成！"
```

## 5. 监控与运维

### 5.1 监控配置

```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "rules/*.yml"

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

scrape_configs:
  - job_name: 'taishang-api'
    static_configs:
      - targets: ['taishang-api:8080']
    metrics_path: /metrics
    scrape_interval: 10s
    
  - job_name: 'laojun-api'
    static_configs:
      - targets: ['laojun-api:8081']
    metrics_path: /metrics
    scrape_interval: 10s
    
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
      
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

### 5.2 日志管理

```go
// 日志管理实现
package logging

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "github.com/sirupsen/logrus"
    "go.opentelemetry.io/otel/trace"
)

type Logger struct {
    *logrus.Logger
    serviceName string
}

type LogEntry struct {
    Timestamp   time.Time              `json:"timestamp"`
    Level       string                 `json:"level"`
    Service     string                 `json:"service"`
    TraceID     string                 `json:"trace_id,omitempty"`
    SpanID      string                 `json:"span_id,omitempty"`
    Message     string                 `json:"message"`
    Fields      map[string]interface{} `json:"fields,omitempty"`
    Error       string                 `json:"error,omitempty"`
    Stack       string                 `json:"stack,omitempty"`
}

func NewLogger(serviceName string) *Logger {
    logger := logrus.New()
    logger.SetFormatter(&logrus.JSONFormatter{
        TimestampFormat: time.RFC3339,
    })
    
    return &Logger{
        Logger:      logger,
        serviceName: serviceName,
    }
}

func (l *Logger) WithContext(ctx context.Context) *logrus.Entry {
    entry := l.Logger.WithContext(ctx)
    
    // 添加追踪信息
    if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
        spanCtx := span.SpanContext()
        entry = entry.WithFields(logrus.Fields{
            "trace_id": spanCtx.TraceID().String(),
            "span_id":  spanCtx.SpanID().String(),
        })
    }
    
    // 添加服务名
    entry = entry.WithField("service", l.serviceName)
    
    return entry
}

func (l *Logger) LogRequirement(ctx context.Context, action string, requirementID string, details map[string]interface{}) {
    l.WithContext(ctx).WithFields(logrus.Fields{
        "action":         action,
        "requirement_id": requirementID,
        "details":        details,
    }).Info("Requirement operation")
}

func (l *Logger) LogCoordinate(ctx context.Context, action string, coordinate interface{}, confidence float64) {
    l.WithContext(ctx).WithFields(logrus.Fields{
        "action":     action,
        "coordinate": coordinate,
        "confidence": confidence,
    }).Info("Coordinate operation")
}

func (l *Logger) LogError(ctx context.Context, err error, message string, fields map[string]interface{}) {
    entry := l.WithContext(ctx).WithError(err)
    
    if fields != nil {
        entry = entry.WithFields(fields)
    }
    
    entry.Error(message)
}
```

## 6. 安全指南

### 6.1 认证与授权

```go
// 安全认证实现
package security

import (
    "context"
    "crypto/rsa"
    "fmt"
    "time"
    "github.com/golang-jwt/jwt/v4"
    "golang.org/x/crypto/bcrypt"
)

type AuthService struct {
    privateKey *rsa.PrivateKey
    publicKey  *rsa.PublicKey
    issuer     string
}

type Claims struct {
    UserID      string   `json:"user_id"`
    Email       string   `json:"email"`
    Roles       []string `json:"roles"`
    Permissions []string `json:"permissions"`
    DeviceID    string   `json:"device_id,omitempty"`
    jwt.RegisteredClaims
}

func NewAuthService(privateKey *rsa.PrivateKey, publicKey *rsa.PublicKey, issuer string) *AuthService {
    return &AuthService{
        privateKey: privateKey,
        publicKey:  publicKey,
        issuer:     issuer,
    }
}

func (a *AuthService) GenerateToken(userID, email string, roles, permissions []string, deviceID string) (string, error) {
    claims := Claims{
        UserID:      userID,
        Email:       email,
        Roles:       roles,
        Permissions: permissions,
        DeviceID:    deviceID,
        RegisteredClaims: jwt.RegisteredClaims{
            Issuer:    a.issuer,
            Subject:   userID,
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            NotBefore: jwt.NewNumericDate(time.Now()),
        },
    }
    
    token := jwt.NewWithClaims(jwt.SigningMethodRS256, claims)
    return token.SignedString(a.privateKey)
}

func (a *AuthService) ValidateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return a.publicKey, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }
    
    return nil, fmt.Errorf("invalid token")
}

func (a *AuthService) HashPassword(password string) (string, error) {
    bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    return string(bytes), err
}

func (a *AuthService) CheckPassword(password, hash string) bool {
    err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
    return err == nil
}

// 权限检查中间件
func (a *AuthService) RequirePermission(permission string) gin.HandlerFunc {
    return func(c *gin.Context) {
        claims, exists := c.Get("claims")
        if !exists {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "No authentication claims"})
            c.Abort()
            return
        }
        
        userClaims, ok := claims.(*Claims)
        if !ok {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid claims"})
            c.Abort()
            return
        }
        
        hasPermission := false
        for _, p := range userClaims.Permissions {
            if p == permission || p == "admin" {
                hasPermission = true
                break
            }
        }
        
        if !hasPermission {
            c.JSON(http.StatusForbidden, gin.H{"error": "Insufficient permissions"})
            c.Abort()
            return
        }
        
        c.Next()
    }
}
```

### 6.2 数据加密

```go
// 数据加密实现
package encryption

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/base64"
    "fmt"
    "io"
)

type EncryptionService struct {
    key []byte
}

func NewEncryptionService(secretKey string) *EncryptionService {
    hash := sha256.Sum256([]byte(secretKey))
    return &EncryptionService{
        key: hash[:],
    }
}

func (e *EncryptionService) Encrypt(plaintext string) (string, error) {
    block, err := aes.NewCipher(e.key)
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonce := make([]byte, gcm.NonceSize())
    if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
        return "", err
    }
    
    ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
    return base64.StdEncoding.EncodeToString(ciphertext), nil
}

func (e *EncryptionService) Decrypt(ciphertext string) (string, error) {
    data, err := base64.StdEncoding.DecodeString(ciphertext)
    if err != nil {
        return "", err
    }
    
    block, err := aes.NewCipher(e.key)
    if err != nil {
        return "", err
    }
    
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }
    
    nonceSize := gcm.NonceSize()
    if len(data) < nonceSize {
        return "", fmt.Errorf("ciphertext too short")
    }
    
    nonce, ciphertext := data[:nonceSize], data[nonceSize:]
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return "", err
    }
    
    return string(plaintext), nil
}

// 敏感数据字段加密
type EncryptedField struct {
    value           string
    encryptionService *EncryptionService
}

func NewEncryptedField(value string, service *EncryptionService) (*EncryptedField, error) {
    encrypted, err := service.Encrypt(value)
    if err != nil {
        return nil, err
    }
    
    return &EncryptedField{
        value:           encrypted,
        encryptionService: service,
    }, nil
}

func (ef *EncryptedField) GetValue() (string, error) {
    return ef.encryptionService.Decrypt(ef.value)
}

func (ef *EncryptedField) SetValue(value string) error {
    encrypted, err := ef.encryptionService.Encrypt(value)
    if err != nil {
        return err
    }
    ef.value = encrypted
    return nil
}
```

## 7. 性能优化

### 7.1 缓存策略

```go
// 缓存策略实现
package cache

import (
    "context"
    "encoding/json"
    "fmt"
    "time"
    "github.com/go-redis/redis/v8"
)

type CacheService struct {
    client *redis.Client
    prefix string
}

func NewCacheService(client *redis.Client, prefix string) *CacheService {
    return &CacheService{
        client: client,
        prefix: prefix,
    }
}

func (c *CacheService) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) error {
    data, err := json.Marshal(value)
    if err != nil {
        return err
    }
    
    fullKey := fmt.Sprintf("%s:%s", c.prefix, key)
    return c.client.Set(ctx, fullKey, data, expiration).Err()
}

func (c *CacheService) Get(ctx context.Context, key string, dest interface{}) error {
    fullKey := fmt.Sprintf("%s:%s", c.prefix, key)
    data, err := c.client.Get(ctx, fullKey).Result()
    if err != nil {
        return err
    }
    
    return json.Unmarshal([]byte(data), dest)
}

func (c *CacheService) Delete(ctx context.Context, key string) error {
    fullKey := fmt.Sprintf("%s:%s", c.prefix, key)
    return c.client.Del(ctx, fullKey).Err()
}

// 智能缓存装饰器
func (c *CacheService) WithCache(
    key string,
    expiration time.Duration,
    fn func() (interface{}, error),
) func() (interface{}, error) {
    return func() (interface{}, error) {
        ctx := context.Background()
        
        // 尝试从缓存获取
        var cached interface{}
        if err := c.Get(ctx, key, &cached); err == nil {
            return cached, nil
        }
        
        // 缓存未命中，执行原函数
        result, err := fn()
        if err != nil {
            return nil, err
        }
        
        // 存入缓存
        c.Set(ctx, key, result, expiration)
        
        return result, nil
    }
}

// 三轴坐标缓存
type CoordinateCache struct {
    cache *CacheService
}

func NewCoordinateCache(cache *CacheService) *CoordinateCache {
    return &CoordinateCache{cache: cache}
}

func (cc *CoordinateCache) GetCoordinate(requirementID string) (*ThreeAxisCoordinate, error) {
    key := fmt.Sprintf("coordinate:%s", requirementID)
    var coordinate ThreeAxisCoordinate
    
    err := cc.cache.Get(context.Background(), key, &coordinate)
    if err != nil {
        return nil, err
    }
    
    return &coordinate, nil
}

func (cc *CoordinateCache) SetCoordinate(requirementID string, coordinate *ThreeAxisCoordinate) error {
    key := fmt.Sprintf("coordinate:%s", requirementID)
    return cc.cache.Set(context.Background(), key, coordinate, 24*time.Hour)
}
```

## 8. 测试指南

### 8.1 单元测试

```go
// 单元测试示例
package services_test

import (
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
    "github.com/taishanglaojun/core/models"
    "github.com/taishanglaojun/core/services"
)

// Mock AI分析器
type MockAIAnalyzer struct {
    mock.Mock
}

func (m *MockAIAnalyzer) AnalyzeRequirement(req models.CreateRequirementRequest) (*models.RequirementAnalysis, error) {
    args := m.Called(req)
    return args.Get(0).(*models.RequirementAnalysis), args.Error(1)
}

// 测试需求服务
func TestRequirementService_CreateRequirement(t *testing.T) {
    // 准备测试数据
    mockAI := new(MockAIAnalyzer)
    service := services.NewRequirementService(mockAI)
    
    req := models.CreateRequirementRequest{
        Title:       "测试需求",
        Description: "这是一个测试需求",
        UserID:      "user123",
    }
    
    expectedAnalysis := &models.RequirementAnalysis{
        Priority:   "high",
        Complexity: 75.0,
        Category:   "feature",
    }
    
    // 设置Mock期望
    mockAI.On("AnalyzeRequirement", req).Return(expectedAnalysis, nil)
    
    // 执行测试
    requirement, err := service.CreateRequirement(req)
    
    // 验证结果
    assert.NoError(t, err)
    assert.NotNil(t, requirement)
    assert.Equal(t, req.Title, requirement.Title)
    assert.Equal(t, req.Description, requirement.Description)
    assert.Equal(t, expectedAnalysis.Priority, requirement.Priority)
    
    // 验证Mock调用
    mockAI.AssertExpectations(t)
}

func TestCoordinateEngine_CalculateCoordinate(t *testing.T) {
    engine := services.NewCoordinateEngine()
    
    testCases := []struct {
        name        string
        analysis    *models.RequirementAnalysis
        expectedS   float64
        expectedC   float64
        expectedT   float64
    }{
        {
            name: "高技术复杂度需求",
            analysis: &models.RequirementAnalysis{
                TechComplexity:    90.0,
                CulturalImpact:    30.0,
                TimeUrgency:       50.0,
            },
            expectedS: 90.0,
            expectedC: 30.0,
            expectedT: 50.0,
        },
        {
            name: "高文化影响需求",
            analysis: &models.RequirementAnalysis{
                TechComplexity:    40.0,
                CulturalImpact:    85.0,
                TimeUrgency:       70.0,
            },
            expectedS: 40.0,
            expectedC: 85.0,
            expectedT: 70.0,
        },
    }
    
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            coordinate, err := engine.CalculateCoordinate(tc.analysis)
            
            assert.NoError(t, err)
            assert.NotNil(t, coordinate)
            assert.InDelta(t, tc.expectedS, coordinate.S.Score, 5.0)
            assert.InDelta(t, tc.expectedC, coordinate.C.Score, 5.0)
            assert.InDelta(t, tc.expectedT, coordinate.T.Score, 5.0)
        })
    }
}
```

### 8.2 集成测试

```go
// 集成测试示例
package integration_test

import (
    "bytes"
    "encoding/json"
    "net/http"
    "net/http/httptest"
    "testing"
    "github.com/gin-gonic/gin"
    "github.com/stretchr/testify/assert"
    "github.com/taishanglaojun/api"
    "github.com/taishanglaojun/core/models"
)

func TestRequirementAPI_Integration(t *testing.T) {
    // 设置测试环境
    gin.SetMode(gin.TestMode)
    router := setupTestRouter()
    
    t.Run("创建需求完整流程", func(t *testing.T) {
        // 1. 创建需求
        createReq := models.CreateRequirementRequest{
            Title:       "集成测试需求",
            Description: "这是一个集成测试需求，用于验证完整的创建流程",
            UserID:      "test-user-123",
        }
        
        reqBody, _ := json.Marshal(createReq)
        req := httptest.NewRequest("POST", "/api/v1/requirements", bytes.NewBuffer(reqBody))
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer test-token")
        
        w := httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusCreated, w.Code)
        
        var createResp api.BaseResponse
        err := json.Unmarshal(w.Body.Bytes(), &createResp)
        assert.NoError(t, err)
        assert.True(t, createResp.Success)
        
        // 提取需求ID
        requirementData := createResp.Data.(map[string]interface{})
        requirement := requirementData["requirement"].(map[string]interface{})
        requirementID := requirement["id"].(string)
        
        // 2. 获取需求详情
        req = httptest.NewRequest("GET", "/api/v1/requirements/"+requirementID, nil)
        req.Header.Set("Authorization", "Bearer test-token")
        
        w = httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusOK, w.Code)
        
        var getResp api.BaseResponse
        err = json.Unmarshal(w.Body.Bytes(), &getResp)
        assert.NoError(t, err)
        assert.True(t, getResp.Success)
        
        // 3. 更新需求
        updateReq := models.UpdateRequirementRequest{
            Title:  stringPtr("更新后的需求标题"),
            Status: stringPtr("in_progress"),
            UserID: "test-user-123",
        }
        
        reqBody, _ = json.Marshal(updateReq)
        req = httptest.NewRequest("PUT", "/api/v1/requirements/"+requirementID, bytes.NewBuffer(reqBody))
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer test-token")
        
        w = httptest.NewRecorder()
        router.ServeHTTP(w, req)
        
        assert.Equal(t, http.StatusOK, w.Code)
        
        var updateResp api.BaseResponse
        err = json.Unmarshal(w.Body.Bytes(), &updateResp)
        assert.NoError(t, err)
        assert.True(t, updateResp.Success)
    })
}

func stringPtr(s string) *string {
    return &s
}
```

## 9. 故障排除

### 9.1 常见问题

#### 9.1.1 API响应慢

**问题描述**: API响应时间超过预期

**排查步骤**:
1. 检查数据库查询性能
2. 检查缓存命中率
3. 检查AI服务响应时间
4. 检查网络延迟

**解决方案**:
```go
// 性能监控中间件
func PerformanceMonitoringMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        
        c.Next()
        
        duration := time.Since(start)
        
        // 记录慢请求
        if duration > 1*time.Second {
            log.WithFields(log.Fields{
                "method":   c.Request.Method,
                "path":     c.Request.URL.Path,
                "duration": duration,
                "status":   c.Writer.Status(),
            }).Warn("Slow request detected")
        }
        
        // 记录性能指标
        metrics.RequestDuration.WithLabelValues(
            c.Request.Method,
            c.Request.URL.Path,
        ).Observe(duration.Seconds())
    }
}
```

#### 9.1.2 三轴坐标计算异常

**问题描述**: 三轴坐标计算结果不准确或出现错误

**排查步骤**:
1. 检查输入数据格式
2. 验证AI模型响应
3. 检查坐标计算逻辑
4. 验证置信度阈值

**解决方案**:
```go
// 坐标计算验证
func (ce *CoordinateEngine) ValidateCoordinate(coordinate *ThreeAxisCoordinate) error {
    // 验证分数范围
    if coordinate.S.Score < 0 || coordinate.S.Score > 100 {
        return fmt.Errorf("S轴分数超出范围: %f", coordinate.S.Score)
    }
    if coordinate.C.Score < 0 || coordinate.C.Score > 100 {
        return fmt.Errorf("C轴分数超出范围: %f", coordinate.C.Score)
    }
    if coordinate.T.Score < 0 || coordinate.T.Score > 100 {
        return fmt.Errorf("T轴分数超出范围: %f", coordinate.T.Score)
    }
    
    // 验证置信度
    if coordinate.S.Confidence < 0 || coordinate.S.Confidence > 1 {
        return fmt.Errorf("S轴置信度超出范围: %f", coordinate.S.Confidence)
    }
    if coordinate.C.Confidence < 0 || coordinate.C.Confidence > 1 {
        return fmt.Errorf("C轴置信度超出范围: %f", coordinate.C.Confidence)
    }
    if coordinate.T.Confidence < 0 || coordinate.T.Confidence > 1 {
        return fmt.Errorf("T轴置信度超出范围: %f", coordinate.T.Confidence)
    }
    
    return nil
}
```

### 9.2 日志分析

```bash
#!/bin/bash
# scripts/analyze-logs.sh

# 分析API错误日志
echo "=== API错误统计 ==="
grep "ERROR" /var/log/taishang/*.log | \
    jq -r '.error.code' | \
    sort | uniq -c | sort -nr

# 分析慢查询
echo "=== 慢查询统计 ==="
grep "Slow request" /var/log/taishang/*.log | \
    jq -r '.path' | \
    sort | uniq -c | sort -nr

# 分析三轴坐标计算
echo "=== 坐标计算统计 ==="
grep "Coordinate operation" /var/log/taishang/*.log | \
    jq -r '.confidence' | \
    awk '{sum+=$1; count++} END {print "平均置信度:", sum/count}'

# 分析用户活跃度
echo "=== 用户活跃度 ==="
grep "user_id" /var/log/taishang/*.log | \
    jq -r '.user_id' | \
    sort | uniq -c | sort -nr | head -10
```

## 10. 总结

太上老君协同机制集成文档详细描述了基于S×C×T三轴协同理念的众包协作开发平台的完整实现方案。通过"太上"智慧决策层和"老君"智能执行层的深度融合，实现了：

### 10.1 核心价值

1. **智能决策**: 基于AI的需求分析和三轴坐标计算
2. **精准匹配**: 智能开发者匹配和任务分配
3. **无缝协作**: 跨平台实时协作和同步
4. **质量保障**: 多维度质量控制和评估
5. **持续优化**: 自适应学习和系统演进

### 10.2 技术特色

1. **三轴坐标系统**: 创新的S×C×T三维评估体系
2. **多端统一**: 支持PC、移动、手表等多种设备
3. **实时同步**: 基于WebSocket的实时协作
4. **AI驱动**: 深度集成大语言模型和机器学习
5. **云原生**: 基于Kubernetes的容器化部署

### 10.3 未来展望

太上老君平台将持续演进，朝着"Sequence 0"的终极目标迈进，构建一个真正智能、高效、包容的全球化协作开发生态系统。

---

## 源界生态系统整合

### 「源界」概念说明
一个融合学习、实践与社交的数字世界，可作为平台独立板块或完整生态系统。旨在通过以下方式整合：
- 太上老君AI技术体系
- 源界数字世界
- 用户参与机制

### 「源界」核心理论体系

#### 1. 源力理论
- **本源代码**：世界构建基础单元
- **算法法则**：数字世界物理规律
- **架构之道**：系统设计根本原则
- **数据流**：信息能量流动

#### 2. 数字修行体系
- **第一境：识码** - 理解代码本质
- **第二境：构界** - 构建数字世界
- **第三境：融实** - 实现虚实融合
- **第四境：创世** - 创造新宇宙

### 实施路径

#### 第一阶段：理论建设
- 《源界创世录》：数字世界构建原理
- 《码修心法》：技术修行方法论
- 《算法法则》：数字世界运行规律

#### 第二阶段：实践体系
数字修行课程体系：
- 基础课：《从Hello World到宇宙构建》
- 进阶课：《架构设计与系统演化》
- 高阶课：《人工智能与意识觉醒》

#### 第三阶段：社区生态
源界社区特色功能：
- 技术道场：线上编程实践空间
- 代码禅修：深度编程冥想
- 开源布道：通过项目传播理念

---

**文档版本**: v1.0 (太上老君协同机制核心集成方案)  
**创建时间**: 2025年10月  
**最后更新**: 2025年10月  
**创建人员**: Li da  
**维护团队**: 源界-突击队  
**联系方式**: dev@codetaoist.com  
**更新频率**: 每两周更新

本文档是"太上老君AI+源界+用户"三位一体生态系统的核心组成部分，致力于构建融合技术创新与哲学智慧的数字修行平台。