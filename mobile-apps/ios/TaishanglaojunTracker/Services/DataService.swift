//
//  DataService.swift
//  TaishanglaojunTracker
//
//  Created by Taishanglaojun Team
//

import Foundation
import CoreData
import Combine
import CryptoKit

/// Êï∞ÊçÆÊúçÂä°ÁÆ°ÁêÜÂô®
class DataService: ObservableObject {
    
    // MARK: - Published Properties
    @Published var trajectories: [Trajectory] = []
    @Published var isLoading = false
    @Published var syncStatus: SyncStatus = .idle
    
    // MARK: - Private Properties
    private let networkService = NetworkService.shared
    private let cryptoService = CryptoService.shared
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Core Data Stack
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "TaishanglaojunTracker")
        container.loadPersistentStores { _, error in
            if let error = error {
                fatalError("Core Data error: \(error)")
            }
        }
        return container
    }()
    
    private var context: NSManagedObjectContext {
        persistentContainer.viewContext
    }
    
    // MARK: - Singleton
    static let shared = DataService()
    
    private init() {
        loadTrajectories()
        setupAutoSync()
    }
    
    // MARK: - Trajectory Management
    
    /// ‰øùÂ≠òËΩ®Ëøπ
    func saveTrajectory(_ trajectory: Trajectory) {
        // Âä†ÂØÜÊïèÊÑüÊï∞ÊçÆ
        let encryptedTrajectory = cryptoService.encryptTrajectory(trajectory)
        
        // ‰øùÂ≠òÂà∞Êú¨Âú∞Êï∞ÊçÆÂ∫ì
        saveToLocalDatabase(encryptedTrajectory)
        
        // Ê∑ªÂä†Âà∞ÂÜÖÂ≠òÊï∞ÁªÑ
        if let index = trajectories.firstIndex(where: { $0.id == trajectory.id }) {
            trajectories[index] = trajectory
        } else {
            trajectories.append(trajectory)
        }
        
        // ÂºÇÊ≠•‰∏ä‰º†Âà∞ÊúçÂä°Âô®
        uploadTrajectoryAsync(trajectory)
        
        print("üíæ ËΩ®ËøπÂ∑≤‰øùÂ≠ò: \(trajectory.name)")
    }
    
    /// Âà†Èô§ËΩ®Ëøπ
    func deleteTrajectory(_ trajectory: Trajectory) {
        // ‰ªéÊú¨Âú∞Êï∞ÊçÆÂ∫ìÂà†Èô§
        deleteFromLocalDatabase(trajectory.id)
        
        // ‰ªéÂÜÖÂ≠òÊï∞ÁªÑÂà†Èô§
        trajectories.removeAll { $0.id == trajectory.id }
        
        // ‰ªéÊúçÂä°Âô®Âà†Èô§
        deleteTrajectoryFromServer(trajectory.id)
        
        print("üóëÔ∏è ËΩ®ËøπÂ∑≤Âà†Èô§: \(trajectory.name)")
    }
    
    /// Êõ¥Êñ∞ËΩ®Ëøπ
    func updateTrajectory(_ trajectory: Trajectory) {
        saveTrajectory(trajectory)
    }
    
    /// Ëé∑ÂèñËΩ®ËøπËØ¶ÊÉÖ
    func getTrajectory(by id: UUID) -> Trajectory? {
        return trajectories.first { $0.id == id }
    }
    
    // MARK: - Local Database Operations
    
    private func saveToLocalDatabase(_ trajectory: Trajectory) {
        let entity = NSEntityDescription.entity(forEntityName: "TrajectoryEntity", in: context)!
        let trajectoryEntity = NSManagedObject(entity: entity, insertInto: context)
        
        trajectoryEntity.setValue(trajectory.id.uuidString, forKey: "id")
        trajectoryEntity.setValue(trajectory.name, forKey: "name")
        trajectoryEntity.setValue(trajectory.startTime, forKey: "startTime")
        trajectoryEntity.setValue(trajectory.endTime, forKey: "endTime")
        
        // Â∫èÂàóÂåñ‰ΩçÁΩÆÁÇπÊï∞ÊçÆ
        if let pointsData = try? JSONEncoder().encode(trajectory.points) {
            let encryptedData = cryptoService.encrypt(pointsData)
            trajectoryEntity.setValue(encryptedData, forKey: "pointsData")
        }
        
        saveContext()
    }
    
    private func loadTrajectories() {
        isLoading = true
        
        let request: NSFetchRequest<NSManagedObject> = NSFetchRequest(entityName: "TrajectoryEntity")
        request.sortDescriptors = [NSSortDescriptor(key: "startTime", ascending: false)]
        
        do {
            let results = try context.fetch(request)
            var loadedTrajectories: [Trajectory] = []
            
            for result in results {
                if let trajectory = parseTrajectoryEntity(result) {
                    loadedTrajectories.append(trajectory)
                }
            }
            
            DispatchQueue.main.async {
                self.trajectories = loadedTrajectories
                self.isLoading = false
            }
            
            print("üìö Â∑≤Âä†ËΩΩ \(loadedTrajectories.count) Êù°ËΩ®Ëøπ")
            
        } catch {
            print("‚ùå Âä†ËΩΩËΩ®ËøπÂ§±Ë¥•: \(error)")
            isLoading = false
        }
    }
    
    private func parseTrajectoryEntity(_ entity: NSManagedObject) -> Trajectory? {
        guard let idString = entity.value(forKey: "id") as? String,
              let id = UUID(uuidString: idString),
              let name = entity.value(forKey: "name") as? String,
              let startTime = entity.value(forKey: "startTime") as? Date else {
            return nil
        }
        
        var trajectory = Trajectory(id: id, name: name)
        trajectory.startTime = startTime
        trajectory.endTime = entity.value(forKey: "endTime") as? Date
        
        // Ëß£ÂØÜÂπ∂Ëß£Êûê‰ΩçÁΩÆÁÇπÊï∞ÊçÆ
        if let encryptedData = entity.value(forKey: "pointsData") as? Data,
           let decryptedData = cryptoService.decrypt(encryptedData),
           let points = try? JSONDecoder().decode([LocationPoint].self, from: decryptedData) {
            trajectory.points = points
        }
        
        return trajectory
    }
    
    private func deleteFromLocalDatabase(_ id: UUID) {
        let request: NSFetchRequest<NSManagedObject> = NSFetchRequest(entityName: "TrajectoryEntity")
        request.predicate = NSPredicate(format: "id == %@", id.uuidString)
        
        do {
            let results = try context.fetch(request)
            for result in results {
                context.delete(result)
            }
            saveContext()
        } catch {
            print("‚ùå Âà†Èô§ËΩ®ËøπÂ§±Ë¥•: \(error)")
        }
    }
    
    private func saveContext() {
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                print("‚ùå ‰øùÂ≠ò‰∏ä‰∏ãÊñáÂ§±Ë¥•: \(error)")
            }
        }
    }
    
    // MARK: - Network Sync
    
    private func setupAutoSync() {
        // ÊØè5ÂàÜÈíüËá™Âä®ÂêåÊ≠•‰∏ÄÊ¨°
        Timer.publish(every: 300, on: .main, in: .common)
            .autoconnect()
            .sink { _ in
                self.syncWithServer()
            }
            .store(in: &cancellables)
    }
    
    /// ‰∏éÊúçÂä°Âô®ÂêåÊ≠•
    func syncWithServer() {
        guard syncStatus != .syncing else { return }
        
        syncStatus = .syncing
        
        // ‰∏ä‰º†Êú¨Âú∞Êú™ÂêåÊ≠•ÁöÑËΩ®Ëøπ
        let unsyncedTrajectories = trajectories.filter { !$0.isSynced }
        
        let uploadTasks = unsyncedTrajectories.map { trajectory in
            uploadTrajectory(trajectory)
        }
        
        Publishers.MergeMany(uploadTasks)
            .collect()
            .sink(
                receiveCompletion: { completion in
                    DispatchQueue.main.async {
                        switch completion {
                        case .finished:
                            self.syncStatus = .success
                        case .failure(let error):
                            self.syncStatus = .failed(error)
                        }
                    }
                },
                receiveValue: { _ in
                    print("‚úÖ ÂêåÊ≠•ÂÆåÊàê")
                }
            )
            .store(in: &cancellables)
    }
    
    private func uploadTrajectoryAsync(_ trajectory: Trajectory) {
        uploadTrajectory(trajectory)
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        print("‚ùå ‰∏ä‰º†ËΩ®ËøπÂ§±Ë¥•: \(error)")
                    }
                },
                receiveValue: { success in
                    if success {
                        print("‚úÖ ËΩ®Ëøπ‰∏ä‰º†ÊàêÂäü: \(trajectory.name)")
                    }
                }
            )
            .store(in: &cancellables)
    }
    
    private func uploadTrajectory(_ trajectory: Trajectory) -> AnyPublisher<Bool, Error> {
        return networkService.uploadTrajectory(trajectory)
            .map { _ in true }
            .eraseToAnyPublisher()
    }
    
    private func deleteTrajectoryFromServer(_ id: UUID) {
        networkService.deleteTrajectory(id)
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        print("‚ùå Âà†Èô§ÊúçÂä°Âô®ËΩ®ËøπÂ§±Ë¥•: \(error)")
                    }
                },
                receiveValue: { success in
                    if success {
                        print("‚úÖ ÊúçÂä°Âô®ËΩ®ËøπÂà†Èô§ÊàêÂäü")
                    }
                }
            )
            .store(in: &cancellables)
    }
}

// MARK: - Export Functions
extension DataService {
    
    /// ÂØºÂá∫ËΩ®Ëøπ‰∏∫GPXÊñá‰ª∂
    func exportTrajectoryAsGPX(_ trajectory: Trajectory) -> URL? {
        let gpxContent = trajectory.exportToGPX()
        
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileName = "\(trajectory.name)_\(DateFormatter.fileNameDate.string(from: trajectory.startTime)).gpx"
        let fileURL = documentsPath.appendingPathComponent(fileName)
        
        do {
            try gpxContent.write(to: fileURL, atomically: true, encoding: .utf8)
            return fileURL
        } catch {
            print("‚ùå ÂØºÂá∫GPXÂ§±Ë¥•: \(error)")
            return nil
        }
    }
    
    /// ÂØºÂá∫ËΩ®Ëøπ‰∏∫JSONÊñá‰ª∂
    func exportTrajectoryAsJSON(_ trajectory: Trajectory) -> URL? {
        guard let jsonData = trajectory.exportToJSON() else { return nil }
        
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileName = "\(trajectory.name)_\(DateFormatter.fileNameDate.string(from: trajectory.startTime)).json"
        let fileURL = documentsPath.appendingPathComponent(fileName)
        
        do {
            try jsonData.write(to: fileURL)
            return fileURL
        } catch {
            print("‚ùå ÂØºÂá∫JSONÂ§±Ë¥•: \(error)")
            return nil
        }
    }
}

// MARK: - Statistics
extension DataService {
    
    /// Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ
    var statistics: TrackingStatistics {
        let totalDistance = trajectories.reduce(0) { $0 + $1.totalDistance }
        let totalDuration = trajectories.reduce(0) { $0 + $1.duration }
        let totalTrajectories = trajectories.count
        
        return TrackingStatistics(
            totalDistance: totalDistance,
            totalDuration: totalDuration,
            totalTrajectories: totalTrajectories,
            averageDistance: totalTrajectories > 0 ? totalDistance / Double(totalTrajectories) : 0,
            averageDuration: totalTrajectories > 0 ? totalDuration / Double(totalTrajectories) : 0
        )
    }
}

// MARK: - Supporting Types
enum SyncStatus {
    case idle
    case syncing
    case success
    case failed(Error)
}

struct TrackingStatistics {
    let totalDistance: Double
    let totalDuration: TimeInterval
    let totalTrajectories: Int
    let averageDistance: Double
    let averageDuration: TimeInterval
}

// MARK: - Trajectory Extension
extension Trajectory {
    var isSynced: Bool {
        // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†ÂêåÊ≠•Áä∂ÊÄÅÁöÑÈÄªËæë
        // ÊöÇÊó∂ËøîÂõûfalseÔºåË°®Á§∫ÈúÄË¶ÅÂêåÊ≠•
        return false
    }
}

// MARK: - DateFormatter Extension
private extension DateFormatter {
    static let fileNameDate: DateFormatter = {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd_HH-mm-ss"
        return formatter
    }()
}