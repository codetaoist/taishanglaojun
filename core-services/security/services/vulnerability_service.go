package services

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"net/url"
	"regexp"
	"strings"
	"sync"
	"time"

	"gorm.io/gorm"
	"github.com/codetaoist/taishanglaojun/core-services/security/models"
)

// VulnerabilityService 
type VulnerabilityService struct {
	db     *gorm.DB
	config *VulnerabilityConfig
	
	// ?
	webScanner     *WebVulnerabilityScanner
	networkScanner *NetworkVulnerabilityScanner
	
	// 
	activeScanJobs map[string]*models.ScanJob
	mutex          sync.RWMutex
	
	// 
	stopChan chan bool
	running  bool
}

// VulnerabilityConfig 
type VulnerabilityConfig struct {
	Enabled           bool     `yaml:"enabled"`
	ScanTimeout       int      `yaml:"scan_timeout"`
	MaxConcurrentJobs int      `yaml:"max_concurrent_jobs"`
	ScannerUserAgent  string   `yaml:"scanner_user_agent"`
	ExcludedPaths     []string `yaml:"excluded_paths"`
	ScanDepth         int      `yaml:"scan_depth"`
}

// WebVulnerabilityScanner Web?
type WebVulnerabilityScanner struct {
	client   *http.Client
	patterns map[string][]*regexp.Regexp
}

// NetworkVulnerabilityScanner ?
type NetworkVulnerabilityScanner struct {
	timeout time.Duration
}

// VulnerabilityCheck ?
type VulnerabilityCheck struct {
	Type        string
	Severity    string
	Description string
	Evidence    string
	Solution    string
}

// NewVulnerabilityService 
func NewVulnerabilityService(db *gorm.DB, config *VulnerabilityConfig) *VulnerabilityService {
	service := &VulnerabilityService{
		db:             db,
		config:         config,
		activeScanJobs: make(map[string]*models.ScanJob),
		stopChan:       make(chan bool),
		running:        false,
	}
	
	// 
	service.initScanners()
	
	return service
}

// initScanners 
func (vs *VulnerabilityService) initScanners() {
	// Web?
	vs.webScanner = &WebVulnerabilityScanner{
		client: &http.Client{
			Timeout: time.Duration(vs.config.ScanTimeout) * time.Second,
		},
		patterns: make(map[string][]*regexp.Regexp),
	}
	
	// ?
	vs.initVulnerabilityPatterns()
	
	// 
	vs.networkScanner = &NetworkVulnerabilityScanner{
		timeout: time.Duration(vs.config.ScanTimeout) * time.Second,
	}
}

// initVulnerabilityPatterns ?
func (vs *VulnerabilityService) initVulnerabilityPatterns() {
	patterns := vs.webScanner.patterns
	
	// SQL?
	patterns["sql_injection"] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)mysql_fetch_array\(\)`),
		regexp.MustCompile(`(?i)ORA-\d{5}`),
		regexp.MustCompile(`(?i)Microsoft.*ODBC.*SQL Server`),
		regexp.MustCompile(`(?i)PostgreSQL.*ERROR`),
		regexp.MustCompile(`(?i)Warning.*mysql_.*`),
	}
	
	// XSS?
	patterns["xss"] = []*regexp.Regexp{
		regexp.MustCompile(`<script[^>]*>.*?</script>`),
		regexp.MustCompile(`javascript:`),
		regexp.MustCompile(`on\w+\s*=`),
	}
	
	// ?
	patterns["directory_traversal"] = []*regexp.Regexp{
		regexp.MustCompile(`\.\./`),
		regexp.MustCompile(`\.\.\\`),
		regexp.MustCompile(`%2e%2e%2f`),
		regexp.MustCompile(`%2e%2e%5c`),
	}
	
	// ?
	patterns["information_disclosure"] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)password\s*[:=]\s*[^\s]+`),
		regexp.MustCompile(`(?i)api[_-]?key\s*[:=]\s*[^\s]+`),
		regexp.MustCompile(`(?i)secret\s*[:=]\s*[^\s]+`),
		regexp.MustCompile(`(?i)token\s*[:=]\s*[^\s]+`),
	}
	
	// ?
	patterns["file_inclusion"] = []*regexp.Regexp{
		regexp.MustCompile(`(?i)include\s*\(\s*['"]\s*\.\./`),
		regexp.MustCompile(`(?i)require\s*\(\s*['"]\s*\.\./`),
		regexp.MustCompile(`(?i)file_get_contents\s*\(\s*['"]\s*\.\./`),
	}
}

// Start 
func (vs *VulnerabilityService) Start() {
	if vs.running {
		return
	}
	
	vs.running = true
	log.Println("Starting Vulnerability Service...")
	
	// 
	go vs.monitorScanJobs()
	
	log.Println("Vulnerability Service started successfully")
}

// Stop 
func (vs *VulnerabilityService) Stop() {
	if !vs.running {
		return
	}
	
	log.Println("Stopping Vulnerability Service...")
	vs.stopChan <- true
	vs.running = false
	log.Println("Vulnerability Service stopped")
}

// monitorScanJobs 
func (vs *VulnerabilityService) monitorScanJobs() {
	ticker := time.NewTicker(30 * time.Second)
	defer ticker.Stop()
	
	for {
		select {
		case <-ticker.C:
			vs.checkScanJobStatus()
		case <-vs.stopChan:
			return
		}
	}
}

// checkScanJobStatus ?
func (vs *VulnerabilityService) checkScanJobStatus() {
	vs.mutex.RLock()
	jobs := make([]*models.ScanJob, 0, len(vs.activeScanJobs))
	for _, job := range vs.activeScanJobs {
		jobs = append(jobs, job)
	}
	vs.mutex.RUnlock()
	
	for _, job := range jobs {
		if time.Since(job.StartTime) > time.Duration(vs.config.ScanTimeout)*time.Second {
			vs.timeoutScanJob(job)
		}
	}
}

// timeoutScanJob 
func (vs *VulnerabilityService) timeoutScanJob(job *models.ScanJob) {
	vs.mutex.Lock()
	delete(vs.activeScanJobs, job.ID)
	vs.mutex.Unlock()
	
	job.Status = "timeout"
	job.EndTime = time.Now()
	job.ErrorMessage = "Scan job timed out"
	
	vs.db.Save(job)
	log.Printf("Scan job %s timed out", job.ID)
}

// CreateScanJob 
func (vs *VulnerabilityService) CreateScanJob(ctx context.Context, job *models.ScanJob) error {
	// 鲢?
	vs.mutex.RLock()
	activeCount := len(vs.activeScanJobs)
	vs.mutex.RUnlock()
	
	if activeCount >= vs.config.MaxConcurrentJobs {
		return fmt.Errorf("maximum concurrent scan jobs reached: %d", vs.config.MaxConcurrentJobs)
	}
	
	// 
	job.Status = "pending"
	job.StartTime = time.Now()
	
	if err := vs.db.WithContext(ctx).Create(job).Error; err != nil {
		return err
	}
	
	// ?
	vs.mutex.Lock()
	vs.activeScanJobs[job.ID] = job
	vs.mutex.Unlock()
	
	// 
	go vs.executeScanJob(job)
	
	return nil
}

// executeScanJob 
func (vs *VulnerabilityService) executeScanJob(job *models.ScanJob) {
	defer func() {
		vs.mutex.Lock()
		delete(vs.activeScanJobs, job.ID)
		vs.mutex.Unlock()
	}()
	
	log.Printf("Starting scan job: %s (Type: %s, Target: %s)", job.ID, job.ScanType, job.Target)
	
	job.Status = "running"
	vs.db.Save(job)
	
	var vulnerabilities []models.Vulnerability
	var err error
	
	switch job.ScanType {
	case "web":
		vulnerabilities, err = vs.scanWebTarget(job.Target, job.Config)
	case "network":
		vulnerabilities, err = vs.scanNetworkTarget(job.Target, job.Config)
	case "comprehensive":
		webVulns, webErr := vs.scanWebTarget(job.Target, job.Config)
		netVulns, netErr := vs.scanNetworkTarget(job.Target, job.Config)
		
		if webErr != nil && netErr != nil {
			err = fmt.Errorf("both web and network scans failed: web=%v, network=%v", webErr, netErr)
		} else {
			vulnerabilities = append(vulnerabilities, webVulns...)
			vulnerabilities = append(vulnerabilities, netVulns...)
		}
	default:
		err = fmt.Errorf("unsupported scan type: %s", job.ScanType)
	}
	
	// ?
	job.EndTime = time.Now()
	if err != nil {
		job.Status = "failed"
		job.ErrorMessage = err.Error()
		log.Printf("Scan job %s failed: %v", job.ID, err)
	} else {
		job.Status = "completed"
		job.VulnerabilitiesFound = len(vulnerabilities)
		log.Printf("Scan job %s completed, found %d vulnerabilities", job.ID, len(vulnerabilities))
	}
	
	vs.db.Save(job)
	
	// 淢?
	for _, vuln := range vulnerabilities {
		vuln.ScanJobID = job.ID
		vs.db.Create(&vuln)
	}
}

// scanWebTarget Web
func (vs *VulnerabilityService) scanWebTarget(target string, config models.JSONB) ([]models.Vulnerability, error) {
	log.Printf("Starting web vulnerability scan for target: %s", target)
	
	var vulnerabilities []models.Vulnerability
	
	// URL
	targetURL, err := url.Parse(target)
	if err != nil {
		return nil, fmt.Errorf("invalid target URL: %v", err)
	}
	
	// 
	resp, err := vs.webScanner.client.Get(target)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to target: %v", err)
	}
	defer resp.Body.Close()
	
	// HTTP?
	headerVulns := vs.checkSecurityHeaders(targetURL, resp)
	vulnerabilities = append(vulnerabilities, headerVulns...)
	
	// 鳣?
	commonVulns := vs.checkCommonVulnerabilities(targetURL)
	vulnerabilities = append(vulnerabilities, commonVulns...)
	
	// SQL
	sqlVulns := vs.checkSQLInjection(targetURL)
	vulnerabilities = append(vulnerabilities, sqlVulns...)
	
	// XSS
	xssVulns := vs.checkXSS(targetURL)
	vulnerabilities = append(vulnerabilities, xssVulns...)
	
	// ?
	dirVulns := vs.checkDirectoryTraversal(targetURL)
	vulnerabilities = append(vulnerabilities, dirVulns...)
	
	return vulnerabilities, nil
}

// scanNetworkTarget 
func (vs *VulnerabilityService) scanNetworkTarget(target string, config models.JSONB) ([]models.Vulnerability, error) {
	log.Printf("Starting network vulnerability scan for target: %s", target)
	
	var vulnerabilities []models.Vulnerability
	
	// 
	portVulns := vs.scanPorts(target)
	vulnerabilities = append(vulnerabilities, portVulns...)
	
	// 
	serviceVulns := vs.identifyServices(target)
	vulnerabilities = append(vulnerabilities, serviceVulns...)
	
	return vulnerabilities, nil
}

// checkSecurityHeaders HTTP?
func (vs *VulnerabilityService) checkSecurityHeaders(targetURL *url.URL, resp *http.Response) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	securityHeaders := map[string]string{
		"X-Frame-Options":           "Clickjacking protection",
		"X-Content-Type-Options":    "MIME type sniffing protection",
		"X-XSS-Protection":          "XSS protection",
		"Strict-Transport-Security": "HTTPS enforcement",
		"Content-Security-Policy":   "Content injection protection",
	}
	
	for header, description := range securityHeaders {
		if resp.Header.Get(header) == "" {
			vuln := models.Vulnerability{
				Title:       fmt.Sprintf("Missing Security Header: %s", header),
				Description: fmt.Sprintf("The %s header is missing, which provides %s", header, description),
				Severity:    "medium",
				Category:    "configuration",
				Target:      targetURL.String(),
				VulnType:    "missing_security_header",
				Status:      "open",
				Evidence: models.JSONB(map[string]interface{}{
					"missing_header": header,
					"description":    description,
				}),
				Solution: fmt.Sprintf("Add the %s header to improve security", header),
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}
	
	return vulnerabilities
}

// checkCommonVulnerabilities 鳣?
func (vs *VulnerabilityService) checkCommonVulnerabilities(targetURL *url.URL) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	// 鳣?
	sensitiveFiles := []string{
		"/robots.txt",
		"/.env",
		"/config.php",
		"/wp-config.php",
		"/admin",
		"/phpmyadmin",
		"/.git/config",
		"/backup.sql",
	}
	
	for _, file := range sensitiveFiles {
		testURL := targetURL.String() + file
		resp, err := vs.webScanner.client.Get(testURL)
		if err != nil {
			continue
		}
		defer resp.Body.Close()
		
		if resp.StatusCode == 200 {
			vuln := models.Vulnerability{
				Title:       fmt.Sprintf("Sensitive File Exposed: %s", file),
				Description: fmt.Sprintf("Sensitive file %s is accessible", file),
				Severity:    "high",
				Category:    "information_disclosure",
				Target:      testURL,
				VulnType:    "sensitive_file_exposure",
				Status:      "open",
				Evidence: models.JSONB(map[string]interface{}{
					"file_path":    file,
					"status_code":  resp.StatusCode,
					"content_type": resp.Header.Get("Content-Type"),
				}),
				Solution: fmt.Sprintf("Remove or restrict access to %s", file),
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}
	
	return vulnerabilities
}

// checkSQLInjection SQL
func (vs *VulnerabilityService) checkSQLInjection(targetURL *url.URL) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	// SQL
	payloads := []string{
		"'",
		"\"",
		"' OR '1'='1",
		"\" OR \"1\"=\"1",
		"'; DROP TABLE users; --",
		"' UNION SELECT NULL--",
	}
	
	// URL
	if targetURL.RawQuery != "" {
		for _, payload := range payloads {
			testURL := strings.Replace(targetURL.String(), targetURL.RawQuery, "test="+url.QueryEscape(payload), 1)
			
			resp, err := vs.webScanner.client.Get(testURL)
			if err != nil {
				continue
			}
			defer resp.Body.Close()
			
			// SQL
			body := make([]byte, 4096)
			resp.Body.Read(body)
			bodyStr := string(body)
			
			for _, pattern := range vs.webScanner.patterns["sql_injection"] {
				if pattern.MatchString(bodyStr) {
					vuln := models.Vulnerability{
						Title:       "SQL Injection Vulnerability",
						Description: "Potential SQL injection vulnerability detected",
						Severity:    "high",
						Category:    "injection",
						Target:      testURL,
						VulnType:    "sql_injection",
						Status:      "open",
						Evidence: models.JSONB(map[string]interface{}{
							"payload":     payload,
							"error_match": pattern.String(),
						}),
						Solution: "Use parameterized queries and input validation",
					}
					vulnerabilities = append(vulnerabilities, vuln)
					break
				}
			}
		}
	}
	
	return vulnerabilities
}

// checkXSS XSS
func (vs *VulnerabilityService) checkXSS(targetURL *url.URL) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	// XSS
	payloads := []string{
		"<script>alert('XSS')</script>",
		"<img src=x onerror=alert('XSS')>",
		"javascript:alert('XSS')",
		"<svg onload=alert('XSS')>",
	}
	
	// URL
	if targetURL.RawQuery != "" {
		for _, payload := range payloads {
			testURL := strings.Replace(targetURL.String(), targetURL.RawQuery, "test="+url.QueryEscape(payload), 1)
			
			resp, err := vs.webScanner.client.Get(testURL)
			if err != nil {
				continue
			}
			defer resp.Body.Close()
			
			// 
			body := make([]byte, 4096)
			resp.Body.Read(body)
			bodyStr := string(body)
			
			if strings.Contains(bodyStr, payload) {
				vuln := models.Vulnerability{
					Title:       "Cross-Site Scripting (XSS) Vulnerability",
					Description: "Potential XSS vulnerability detected",
					Severity:    "medium",
					Category:    "injection",
					Target:      testURL,
					VulnType:    "xss",
					Status:      "open",
					Evidence: models.JSONB(map[string]interface{}{
						"payload":   payload,
						"reflected": true,
					}),
					Solution: "Implement proper input validation and output encoding",
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}
	
	return vulnerabilities
}

// checkDirectoryTraversal ?
func (vs *VulnerabilityService) checkDirectoryTraversal(targetURL *url.URL) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	// 
	payloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
		"....//....//....//etc/passwd",
	}
	
	// URL
	if targetURL.RawQuery != "" {
		for _, payload := range payloads {
			testURL := strings.Replace(targetURL.String(), targetURL.RawQuery, "file="+url.QueryEscape(payload), 1)
			
			resp, err := vs.webScanner.client.Get(testURL)
			if err != nil {
				continue
			}
			defer resp.Body.Close()
			
			// ?
			body := make([]byte, 4096)
			resp.Body.Read(body)
			bodyStr := string(body)
			
			// Linux
			if strings.Contains(bodyStr, "root:x:0:0:") || strings.Contains(bodyStr, "# localhost") {
				vuln := models.Vulnerability{
					Title:       "Directory Traversal Vulnerability",
					Description: "Potential directory traversal vulnerability detected",
					Severity:    "high",
					Category:    "injection",
					Target:      testURL,
					VulnType:    "directory_traversal",
					Status:      "open",
					Evidence: models.JSONB(map[string]interface{}{
						"payload":      payload,
						"system_file":  true,
					}),
					Solution: "Implement proper input validation and file access controls",
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}
	
	return vulnerabilities
}

// scanPorts 
func (vs *VulnerabilityService) scanPorts(target string) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	// 
	commonPorts := []int{21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 1433, 3306, 5432, 6379, 27017}
	
	for _, port := range commonPorts {
		address := fmt.Sprintf("%s:%d", target, port)
		conn, err := net.DialTimeout("tcp", address, vs.networkScanner.timeout)
		if err == nil {
			conn.Close()
			
			// 
			if vs.isInsecurePort(port) {
				vuln := models.Vulnerability{
					Title:       fmt.Sprintf("Insecure Service on Port %d", port),
					Description: fmt.Sprintf("Potentially insecure service detected on port %d", port),
					Severity:    "medium",
					Category:    "configuration",
					Target:      address,
					VulnType:    "insecure_service",
					Status:      "open",
					Evidence: models.JSONB(map[string]interface{}{
						"port":    port,
						"service": vs.getServiceName(port),
					}),
					Solution: fmt.Sprintf("Secure or disable the service on port %d", port),
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}
	
	return vulnerabilities
}

// identifyServices 
func (vs *VulnerabilityService) identifyServices(target string) []models.Vulnerability {
	var vulnerabilities []models.Vulnerability
	
	// 
	// banner
	
	return vulnerabilities
}

// isInsecurePort ?
func (vs *VulnerabilityService) isInsecurePort(port int) bool {
	insecurePorts := map[int]bool{
		21:  true, // FTP
		23:  true, // Telnet
		25:  true, // SMTP (unencrypted)
		110: true, // POP3 (unencrypted)
		143: true, // IMAP (unencrypted)
	}
	
	return insecurePorts[port]
}

// getServiceName 
func (vs *VulnerabilityService) getServiceName(port int) string {
	services := map[int]string{
		21:    "FTP",
		22:    "SSH",
		23:    "Telnet",
		25:    "SMTP",
		53:    "DNS",
		80:    "HTTP",
		110:   "POP3",
		143:   "IMAP",
		443:   "HTTPS",
		993:   "IMAPS",
		995:   "POP3S",
		1433:  "SQL Server",
		3306:  "MySQL",
		5432:  "PostgreSQL",
		6379:  "Redis",
		27017: "MongoDB",
	}
	
	if name, exists := services[port]; exists {
		return name
	}
	return "Unknown"
}

// GetScanJobs 
func (vs *VulnerabilityService) GetScanJobs(ctx context.Context, limit, offset int) ([]models.ScanJob, error) {
	var jobs []models.ScanJob
	err := vs.db.WithContext(ctx).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&jobs).Error
	
	return jobs, err
}

// GetScanJob 
func (vs *VulnerabilityService) GetScanJob(ctx context.Context, id string) (*models.ScanJob, error) {
	var job models.ScanJob
	err := vs.db.WithContext(ctx).Where("id = ?", id).First(&job).Error
	if err != nil {
		return nil, err
	}
	
	return &job, nil
}

// GetVulnerabilities 
func (vs *VulnerabilityService) GetVulnerabilities(ctx context.Context, limit, offset int) ([]models.Vulnerability, error) {
	var vulnerabilities []models.Vulnerability
	err := vs.db.WithContext(ctx).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&vulnerabilities).Error
	
	return vulnerabilities, err
}

// GetVulnerability 
func (vs *VulnerabilityService) GetVulnerability(ctx context.Context, id string) (*models.Vulnerability, error) {
	var vulnerability models.Vulnerability
	err := vs.db.WithContext(ctx).Where("id = ?", id).First(&vulnerability).Error
	if err != nil {
		return nil, err
	}
	
	return &vulnerability, nil
}

// UpdateVulnerability ?
func (vs *VulnerabilityService) UpdateVulnerability(ctx context.Context, id string, updates map[string]interface{}) error {
	return vs.db.WithContext(ctx).Model(&models.Vulnerability{}).Where("id = ?", id).Updates(updates).Error
}

// DeleteScanJob 
func (vs *VulnerabilityService) DeleteScanJob(ctx context.Context, id string) error {
	// ?
	if err := vs.db.WithContext(ctx).Where("scan_job_id = ?", id).Delete(&models.Vulnerability{}).Error; err != nil {
		return err
	}
	
	// 
	return vs.db.WithContext(ctx).Delete(&models.ScanJob{}, "id = ?", id).Error
}

// GetVulnerabilityStats 
func (vs *VulnerabilityService) GetVulnerabilityStats(ctx context.Context) (map[string]interface{}, error) {
	stats := make(map[string]interface{})
	
	// 
	var totalCount int64
	vs.db.WithContext(ctx).Model(&models.Vulnerability{}).Count(&totalCount)
	stats["total"] = totalCount
	
	// ?
	severityStats := make(map[string]int64)
	severities := []string{"critical", "high", "medium", "low"}
	for _, severity := range severities {
		var count int64
		vs.db.WithContext(ctx).Model(&models.Vulnerability{}).Where("severity = ?", severity).Count(&count)
		severityStats[severity] = count
	}
	stats["by_severity"] = severityStats
	
	// ?
	statusStats := make(map[string]int64)
	statuses := []string{"open", "fixed", "false_positive", "accepted"}
	for _, status := range statuses {
		var count int64
		vs.db.WithContext(ctx).Model(&models.Vulnerability{}).Where("status = ?", status).Count(&count)
		statusStats[status] = count
	}
	stats["by_status"] = statusStats
	
	// ?
	var typeStats []map[string]interface{}
	vs.db.WithContext(ctx).Model(&models.Vulnerability{}).
		Select("vuln_type, count(*) as count").
		Group("vuln_type").
		Scan(&typeStats)
	stats["by_type"] = typeStats
	
	return stats, nil
}

