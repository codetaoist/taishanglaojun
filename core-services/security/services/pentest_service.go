package services

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net"
	"net/http"
	"net/url"
	"os/exec"
	"regexp"
	"strings"
	"sync"
	"time"

	"gorm.io/gorm"
	"github.com/codetaoist/taishanglaojun/core-services/security/models"
)

// PentestService ?
type PentestService struct {
	db     *gorm.DB
	config *PentestConfig
	
	// 
	nmapScanner    *NmapScanner
	dirBuster      *DirBuster
	sqlMapTester   *SQLMapTester
	
	// 
	activeProjects map[string]*models.PentestProject
	mutex          sync.RWMutex
	
	// 
	stopChan chan bool
	running  bool
}

// PentestConfig ?
type PentestConfig struct {
	Enabled           bool     `yaml:"enabled"`
	MaxConcurrentJobs int      `yaml:"max_concurrent_jobs"`
	ToolsPath         string   `yaml:"tools_path"`
	ReportPath        string   `yaml:"report_path"`
	AllowedTargets    []string `yaml:"allowed_targets"`
	ForbiddenTargets  []string `yaml:"forbidden_targets"`
	TestTimeout       int      `yaml:"test_timeout"`
}

// NmapScanner Nmap?
type NmapScanner struct {
	binaryPath string
	timeout    time.Duration
}

// DirBuster 
type DirBuster struct {
	wordlists []string
	timeout   time.Duration
}

// SQLMapTester SQL
type SQLMapTester struct {
	binaryPath string
	timeout    time.Duration
}

// PentestPhase ?
type PentestPhase struct {
	Name        string
	Description string
	Status      string
	StartTime   time.Time
	EndTime     time.Time
	Results     map[string]interface{}
}

// NewPentestService ?
func NewPentestService(db *gorm.DB, config *PentestConfig) *PentestService {
	service := &PentestService{
		db:             db,
		config:         config,
		activeProjects: make(map[string]*models.PentestProject),
		stopChan:       make(chan bool),
		running:        false,
	}
	
	// ?
	service.initTools()
	
	return service
}

// initTools ?
func (ps *PentestService) initTools() {
	// Nmap?
	ps.nmapScanner = &NmapScanner{
		binaryPath: ps.config.ToolsPath + "/nmap",
		timeout:    time.Duration(ps.config.TestTimeout) * time.Second,
	}
	
	// ?
	ps.dirBuster = &DirBuster{
		wordlists: []string{
			ps.config.ToolsPath + "/wordlists/common.txt",
			ps.config.ToolsPath + "/wordlists/directories.txt",
		},
		timeout: time.Duration(ps.config.TestTimeout) * time.Second,
	}
	
	// SQLMap
	ps.sqlMapTester = &SQLMapTester{
		binaryPath: ps.config.ToolsPath + "/sqlmap",
		timeout:    time.Duration(ps.config.TestTimeout) * time.Second,
	}
}

// Start ?
func (ps *PentestService) Start() {
	if ps.running {
		return
	}
	
	ps.running = true
	log.Println("Starting Pentest Service...")
	
	// 
	go ps.monitorProjects()
	
	log.Println("Pentest Service started successfully")
}

// Stop ?
func (ps *PentestService) Stop() {
	if !ps.running {
		return
	}
	
	log.Println("Stopping Pentest Service...")
	ps.stopChan <- true
	ps.running = false
	log.Println("Pentest Service stopped")
}

// monitorProjects 
func (ps *PentestService) monitorProjects() {
	ticker := time.NewTicker(1 * time.Minute)
	defer ticker.Stop()
	
	for {
		select {
		case <-ticker.C:
			ps.checkProjectStatus()
		case <-ps.stopChan:
			return
		}
	}
}

// checkProjectStatus ?
func (ps *PentestService) checkProjectStatus() {
	ps.mutex.RLock()
	projects := make([]*models.PentestProject, 0, len(ps.activeProjects))
	for _, project := range ps.activeProjects {
		projects = append(projects, project)
	}
	ps.mutex.RUnlock()
	
	for _, project := range projects {
		if time.Since(project.StartTime) > time.Duration(ps.config.TestTimeout)*time.Second {
			ps.timeoutProject(project)
		}
	}
}

// timeoutProject 
func (ps *PentestService) timeoutProject(project *models.PentestProject) {
	ps.mutex.Lock()
	delete(ps.activeProjects, project.ID)
	ps.mutex.Unlock()
	
	project.Status = "timeout"
	project.EndTime = time.Now()
	
	ps.db.Save(project)
	log.Printf("Pentest project %s timed out", project.ID)
}

// CreateProject ?
func (ps *PentestService) CreateProject(ctx context.Context, project *models.PentestProject) error {
	// 
	if !ps.isTargetAllowed(project.Target) {
		return fmt.Errorf("target %s is not allowed for penetration testing", project.Target)
	}
	
	// 鲢?
	ps.mutex.RLock()
	activeCount := len(ps.activeProjects)
	ps.mutex.RUnlock()
	
	if activeCount >= ps.config.MaxConcurrentJobs {
		return fmt.Errorf("maximum concurrent pentest projects reached: %d", ps.config.MaxConcurrentJobs)
	}
	
	// 
	project.Status = "pending"
	project.StartTime = time.Now()
	
	if err := ps.db.WithContext(ctx).Create(project).Error; err != nil {
		return err
	}
	
	// ?
	ps.mutex.Lock()
	ps.activeProjects[project.ID] = project
	ps.mutex.Unlock()
	
	// ?
	go ps.executeProject(project)
	
	return nil
}

// isTargetAllowed ?
func (ps *PentestService) isTargetAllowed(target string) bool {
	// ?
	for _, forbidden := range ps.config.ForbiddenTargets {
		if strings.Contains(target, forbidden) {
			return false
		}
	}
	
	// ?
	if len(ps.config.AllowedTargets) == 0 {
		return true // ?
	}
	
	for _, allowed := range ps.config.AllowedTargets {
		if strings.Contains(target, allowed) {
			return true
		}
	}
	
	return false
}

// executeProject ?
func (ps *PentestService) executeProject(project *models.PentestProject) {
	defer func() {
		ps.mutex.Lock()
		delete(ps.activeProjects, project.ID)
		ps.mutex.Unlock()
	}()
	
	log.Printf("Starting pentest project: %s (Target: %s)", project.ID, project.Target)
	
	project.Status = "running"
	ps.db.Save(project)
	
	// ?
	phases := []string{"reconnaissance", "scanning", "enumeration", "exploitation", "post_exploitation"}
	results := make(map[string]interface{})
	
	for _, phaseName := range phases {
		log.Printf("Executing phase: %s for project %s", phaseName, project.ID)
		
		phaseResult, err := ps.executePhase(project, phaseName)
		if err != nil {
			log.Printf("Phase %s failed for project %s: %v", phaseName, project.ID, err)
			results[phaseName] = map[string]interface{}{
				"status": "failed",
				"error":  err.Error(),
			}
		} else {
			results[phaseName] = phaseResult
		}
		
		// 
		project.Progress = int((float64(len(results)) / float64(len(phases))) * 100)
		ps.db.Save(project)
	}
	
	// 
	report, err := ps.generateReport(project, results)
	if err != nil {
		log.Printf("Failed to generate report for project %s: %v", project.ID, err)
	}
	
	// ?
	project.Status = "completed"
	project.EndTime = time.Now()
	project.Progress = 100
	
	if report != nil {
		// 
		pentestResult := &models.PentestResult{
			ProjectID:   project.ID,
			Phase:       "final_report",
			TestType:    "comprehensive",
			Status:      "completed",
			Severity:    ps.calculateOverallSeverity(results),
			Description: "Comprehensive penetration testing report",
			Evidence:    models.JSONB(results),
			Remediation: "See detailed recommendations in the report",
		}
		ps.db.Create(pentestResult)
	}
	
	ps.db.Save(project)
	log.Printf("Pentest project %s completed", project.ID)
}

// executePhase 
func (ps *PentestService) executePhase(project *models.PentestProject, phase string) (map[string]interface{}, error) {
	switch phase {
	case "reconnaissance":
		return ps.executeReconnaissance(project)
	case "scanning":
		return ps.executeScanning(project)
	case "enumeration":
		return ps.executeEnumeration(project)
	case "exploitation":
		return ps.executeExploitation(project)
	case "post_exploitation":
		return ps.executePostExploitation(project)
	default:
		return nil, fmt.Errorf("unknown phase: %s", phase)
	}
}

// executeReconnaissance 
func (ps *PentestService) executeReconnaissance(project *models.PentestProject) (map[string]interface{}, error) {
	results := make(map[string]interface{})
	
	// DNS
	dnsInfo, err := ps.gatherDNSInfo(project.Target)
	if err != nil {
		log.Printf("DNS reconnaissance failed: %v", err)
	} else {
		results["dns_info"] = dnsInfo
	}
	
	// WHOIS
	whoisInfo, err := ps.gatherWHOISInfo(project.Target)
	if err != nil {
		log.Printf("WHOIS reconnaissance failed: %v", err)
	} else {
		results["whois_info"] = whoisInfo
	}
	
	// ?
	subdomains, err := ps.discoverSubdomains(project.Target)
	if err != nil {
		log.Printf("Subdomain discovery failed: %v", err)
	} else {
		results["subdomains"] = subdomains
	}
	
	results["status"] = "completed"
	results["timestamp"] = time.Now()
	
	return results, nil
}

// executeScanning 
func (ps *PentestService) executeScanning(project *models.PentestProject) (map[string]interface{}, error) {
	results := make(map[string]interface{})
	
	// 
	portScanResults, err := ps.nmapScanner.scanPorts(project.Target)
	if err != nil {
		log.Printf("Port scanning failed: %v", err)
	} else {
		results["port_scan"] = portScanResults
	}
	
	// 汾?
	serviceResults, err := ps.nmapScanner.detectServices(project.Target)
	if err != nil {
		log.Printf("Service detection failed: %v", err)
	} else {
		results["service_detection"] = serviceResults
	}
	
	// ?
	osResults, err := ps.nmapScanner.detectOS(project.Target)
	if err != nil {
		log.Printf("OS detection failed: %v", err)
	} else {
		results["os_detection"] = osResults
	}
	
	results["status"] = "completed"
	results["timestamp"] = time.Now()
	
	return results, nil
}

// executeEnumeration 
func (ps *PentestService) executeEnumeration(project *models.PentestProject) (map[string]interface{}, error) {
	results := make(map[string]interface{})
	
	// 
	dirResults, err := ps.dirBuster.enumerateDirectories(project.Target)
	if err != nil {
		log.Printf("Directory enumeration failed: %v", err)
	} else {
		results["directory_enumeration"] = dirResults
	}
	
	// Web
	fingerprintResults, err := ps.fingerprintWebApp(project.Target)
	if err != nil {
		log.Printf("Web app fingerprinting failed: %v", err)
	} else {
		results["web_fingerprint"] = fingerprintResults
	}
	
	// 
	userResults, err := ps.enumerateUsers(project.Target)
	if err != nil {
		log.Printf("User enumeration failed: %v", err)
	} else {
		results["user_enumeration"] = userResults
	}
	
	results["status"] = "completed"
	results["timestamp"] = time.Now()
	
	return results, nil
}

// executeExploitation 
func (ps *PentestService) executeExploitation(project *models.PentestProject) (map[string]interface{}, error) {
	results := make(map[string]interface{})
	
	// SQL
	sqlResults, err := ps.sqlMapTester.testSQLInjection(project.Target)
	if err != nil {
		log.Printf("SQL injection testing failed: %v", err)
	} else {
		results["sql_injection"] = sqlResults
	}
	
	// XSS
	xssResults, err := ps.testXSS(project.Target)
	if err != nil {
		log.Printf("XSS testing failed: %v", err)
	} else {
		results["xss_testing"] = xssResults
	}
	
	// 
	uploadResults, err := ps.testFileUpload(project.Target)
	if err != nil {
		log.Printf("File upload testing failed: %v", err)
	} else {
		results["file_upload"] = uploadResults
	}
	
	// 
	authResults, err := ps.testAuthBypass(project.Target)
	if err != nil {
		log.Printf("Authentication bypass testing failed: %v", err)
	} else {
		results["auth_bypass"] = authResults
	}
	
	results["status"] = "completed"
	results["timestamp"] = time.Now()
	
	return results, nil
}

// executePostExploitation ?
func (ps *PentestService) executePostExploitation(project *models.PentestProject) (map[string]interface{}, error) {
	results := make(map[string]interface{})
	
	// 
	privescResults, err := ps.testPrivilegeEscalation(project.Target)
	if err != nil {
		log.Printf("Privilege escalation testing failed: %v", err)
	} else {
		results["privilege_escalation"] = privescResults
	}
	
	// 
	lateralResults, err := ps.testLateralMovement(project.Target)
	if err != nil {
		log.Printf("Lateral movement testing failed: %v", err)
	} else {
		results["lateral_movement"] = lateralResults
	}
	
	// 
	dataResults, err := ps.testDataExfiltration(project.Target)
	if err != nil {
		log.Printf("Data exfiltration testing failed: %v", err)
	} else {
		results["data_exfiltration"] = dataResults
	}
	
	results["status"] = "completed"
	results["timestamp"] = time.Now()
	
	return results, nil
}

// gatherDNSInfo DNS
func (ps *PentestService) gatherDNSInfo(target string) (map[string]interface{}, error) {
	info := make(map[string]interface{})
	
	// A
	ips, err := net.LookupIP(target)
	if err == nil {
		var ipStrings []string
		for _, ip := range ips {
			ipStrings = append(ipStrings, ip.String())
		}
		info["a_records"] = ipStrings
	}
	
	// MX
	mxRecords, err := net.LookupMX(target)
	if err == nil {
		var mxStrings []string
		for _, mx := range mxRecords {
			mxStrings = append(mxStrings, mx.Host)
		}
		info["mx_records"] = mxStrings
	}
	
	// TXT
	txtRecords, err := net.LookupTXT(target)
	if err == nil {
		info["txt_records"] = txtRecords
	}
	
	return info, nil
}

// gatherWHOISInfo WHOIS
func (ps *PentestService) gatherWHOISInfo(target string) (map[string]interface{}, error) {
	// WHOIS
	// 
	info := map[string]interface{}{
		"domain": target,
		"note":   "WHOIS information gathering not implemented",
	}
	
	return info, nil
}

// discoverSubdomains ?
func (ps *PentestService) discoverSubdomains(target string) ([]string, error) {
	// ?
	commonSubdomains := []string{"www", "mail", "ftp", "admin", "api", "dev", "test", "staging"}
	var foundSubdomains []string
	
	for _, subdomain := range commonSubdomains {
		fullDomain := subdomain + "." + target
		_, err := net.LookupIP(fullDomain)
		if err == nil {
			foundSubdomains = append(foundSubdomains, fullDomain)
		}
	}
	
	return foundSubdomains, nil
}

// Nmap?
func (ns *NmapScanner) scanPorts(target string) (map[string]interface{}, error) {
	// 
	results := map[string]interface{}{
		"target": target,
		"open_ports": []map[string]interface{}{
			{"port": 80, "service": "http", "state": "open"},
			{"port": 443, "service": "https", "state": "open"},
			{"port": 22, "service": "ssh", "state": "open"},
		},
		"scan_time": time.Now(),
	}
	
	return results, nil
}

func (ns *NmapScanner) detectServices(target string) (map[string]interface{}, error) {
	// ?
	results := map[string]interface{}{
		"target": target,
		"services": []map[string]interface{}{
			{"port": 80, "service": "Apache httpd", "version": "2.4.41"},
			{"port": 443, "service": "Apache httpd", "version": "2.4.41", "ssl": true},
			{"port": 22, "service": "OpenSSH", "version": "8.0"},
		},
	}
	
	return results, nil
}

func (ns *NmapScanner) detectOS(target string) (map[string]interface{}, error) {
	// ?
	results := map[string]interface{}{
		"target": target,
		"os_matches": []map[string]interface{}{
			{"name": "Linux 3.2 - 4.9", "accuracy": "95%"},
			{"name": "Ubuntu 18.04", "accuracy": "90%"},
		},
	}
	
	return results, nil
}

// 
func (db *DirBuster) enumerateDirectories(target string) (map[string]interface{}, error) {
	// 
	results := map[string]interface{}{
		"target": target,
		"found_directories": []map[string]interface{}{
			{"path": "/admin", "status": 200, "size": 1024},
			{"path": "/backup", "status": 403, "size": 0},
			{"path": "/config", "status": 404, "size": 0},
		},
	}
	
	return results, nil
}

// SQLMap
func (smt *SQLMapTester) testSQLInjection(target string) (map[string]interface{}, error) {
	// SQL
	results := map[string]interface{}{
		"target": target,
		"vulnerabilities": []map[string]interface{}{
			{
				"parameter": "id",
				"type":      "boolean-based blind",
				"payload":   "1 AND 1=1",
				"dbms":      "MySQL",
			},
		},
	}
	
	return results, nil
}

// ?
func (ps *PentestService) fingerprintWebApp(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target":     target,
		"technology": "Apache/PHP",
		"cms":        "WordPress",
		"version":    "5.8",
	}, nil
}

func (ps *PentestService) enumerateUsers(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target": target,
		"users":  []string{"admin", "user", "guest"},
	}, nil
}

func (ps *PentestService) testXSS(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target":          target,
		"vulnerabilities": []string{"Reflected XSS in search parameter"},
	}, nil
}

func (ps *PentestService) testFileUpload(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target":          target,
		"vulnerabilities": []string{"Unrestricted file upload"},
	}, nil
}

func (ps *PentestService) testAuthBypass(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target":          target,
		"vulnerabilities": []string{"SQL injection in login form"},
	}, nil
}

func (ps *PentestService) testPrivilegeEscalation(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target": target,
		"methods": []string{"SUID binaries", "Kernel exploits"},
	}, nil
}

func (ps *PentestService) testLateralMovement(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target": target,
		"methods": []string{"Pass-the-hash", "Credential reuse"},
	}, nil
}

func (ps *PentestService) testDataExfiltration(target string) (map[string]interface{}, error) {
	return map[string]interface{}{
		"target": target,
		"methods": []string{"Database dump", "File system access"},
	}, nil
}

// generateReport 
func (ps *PentestService) generateReport(project *models.PentestProject, results map[string]interface{}) (map[string]interface{}, error) {
	report := map[string]interface{}{
		"project_id":   project.ID,
		"target":       project.Target,
		"start_time":   project.StartTime,
		"end_time":     time.Now(),
		"phases":       results,
		"summary":      ps.generateSummary(results),
		"recommendations": ps.generateRecommendations(results),
	}
	
	return report, nil
}

// generateSummary 
func (ps *PentestService) generateSummary(results map[string]interface{}) map[string]interface{} {
	summary := map[string]interface{}{
		"total_vulnerabilities": ps.countVulnerabilities(results),
		"severity_breakdown":    ps.getSeverityBreakdown(results),
		"risk_level":           ps.calculateRiskLevel(results),
	}
	
	return summary
}

// generateRecommendations 
func (ps *PentestService) generateRecommendations(results map[string]interface{}) []string {
	recommendations := []string{
		"Implement input validation for all user inputs",
		"Use parameterized queries to prevent SQL injection",
		"Enable HTTPS for all communications",
		"Implement proper access controls",
		"Regular security updates and patches",
	}
	
	return recommendations
}

// calculateOverallSeverity 
func (ps *PentestService) calculateOverallSeverity(results map[string]interface{}) string {
	// ?
	vulnCount := ps.countVulnerabilities(results)
	
	if vulnCount > 10 {
		return "critical"
	} else if vulnCount > 5 {
		return "high"
	} else if vulnCount > 0 {
		return "medium"
	}
	
	return "low"
}

// countVulnerabilities 
func (ps *PentestService) countVulnerabilities(results map[string]interface{}) int {
	count := 0
	
	for _, phaseResult := range results {
		if phaseMap, ok := phaseResult.(map[string]interface{}); ok {
			if vulns, exists := phaseMap["vulnerabilities"]; exists {
				if vulnSlice, ok := vulns.([]interface{}); ok {
					count += len(vulnSlice)
				}
			}
		}
	}
	
	return count
}

// getSeverityBreakdown 
func (ps *PentestService) getSeverityBreakdown(results map[string]interface{}) map[string]int {
	breakdown := map[string]int{
		"critical": 0,
		"high":     0,
		"medium":   0,
		"low":      0,
	}
	
	// 
	total := ps.countVulnerabilities(results)
	breakdown["high"] = total / 3
	breakdown["medium"] = total / 2
	breakdown["low"] = total - breakdown["high"] - breakdown["medium"]
	
	return breakdown
}

// calculateRiskLevel 
func (ps *PentestService) calculateRiskLevel(results map[string]interface{}) string {
	vulnCount := ps.countVulnerabilities(results)
	
	if vulnCount > 15 {
		return "critical"
	} else if vulnCount > 10 {
		return "high"
	} else if vulnCount > 5 {
		return "medium"
	}
	
	return "low"
}

// GetProjects 
func (ps *PentestService) GetProjects(ctx context.Context, limit, offset int) ([]models.PentestProject, error) {
	var projects []models.PentestProject
	err := ps.db.WithContext(ctx).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&projects).Error
	
	return projects, err
}

// GetProject 
func (ps *PentestService) GetProject(ctx context.Context, id string) (*models.PentestProject, error) {
	var project models.PentestProject
	err := ps.db.WithContext(ctx).Where("id = ?", id).First(&project).Error
	if err != nil {
		return nil, err
	}
	
	return &project, nil
}

// GetProjectResults 
func (ps *PentestService) GetProjectResults(ctx context.Context, projectID string) ([]models.PentestResult, error) {
	var results []models.PentestResult
	err := ps.db.WithContext(ctx).Where("project_id = ?", projectID).Find(&results).Error
	
	return results, err
}

// UpdateProject 
func (ps *PentestService) UpdateProject(ctx context.Context, id string, updates map[string]interface{}) error {
	return ps.db.WithContext(ctx).Model(&models.PentestProject{}).Where("id = ?", id).Updates(updates).Error
}

// DeleteProject 
func (ps *PentestService) DeleteProject(ctx context.Context, id string) error {
	// ?
	if err := ps.db.WithContext(ctx).Where("project_id = ?", id).Delete(&models.PentestResult{}).Error; err != nil {
		return err
	}
	
	// 
	return ps.db.WithContext(ctx).Delete(&models.PentestProject{}, "id = ?", id).Error
}

