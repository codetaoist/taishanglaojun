# 太上老君AI平台 - 安全模块技术架构设计

## 📋 架构概述

本文档详细描述了如何将黑帽与白帽安全功能模块集成到现有的太上老君AI平台中，基于S×C×T三轴体系设计，确保安全功能与平台核心理念的深度融合。

## 🏗️ 整体架构集成

### 1. 现有平台架构回顾

```
太上老君AI平台现有架构:
├── 前端应用层 (Frontend Applications)
│   ├── Web应用 (React + TypeScript)
│   ├── 移动应用 (Android/iOS)
│   └── 桌面应用 (Electron)
├── 基础设施层 (Infrastructure)
│   ├── API网关 (api-gateway)
│   ├── 认证系统 (auth-system)
│   └── 数据库层 (database-layer)
├── 核心服务层 (Core Services)
│   ├── 文化智慧 (cultural-wisdom)
│   ├── 智能学习 (intelligent-learning)
│   └── 轨迹记录 (trajectory-recording)
└── AI智能层 (AI Stack)
    ├── 大语言模型 (LLMs)
    ├── 向量搜索 (Vector Search)
    └── 知识图谱 (Knowledge Graph)
```

### 2. 安全模块集成架构

```
太上老君AI平台 + 安全模块集成架构:
├── 前端应用层 (Frontend Applications)
│   ├── Web应用 (React + TypeScript)
│   │   ├── 安全控制台 (Security Console)
│   │   ├── 渗透测试界面 (Pentest Dashboard)
│   │   └── 安全教育平台 (Security Education)
│   ├── 移动应用 (Android/iOS)
│   │   ├── 安全监控 (Security Monitoring)
│   │   └── 移动安全工具 (Mobile Security Tools)
│   └── 桌面应用 (Electron)
│       ├── 安全分析工具 (Security Analysis)
│       └── 渗透测试客户端 (Pentest Client)
├── 基础设施层 (Infrastructure) [扩展]
│   ├── API网关 (api-gateway) [增强安全功能]
│   │   ├── 安全路由 (Security Routing)
│   │   ├── 威胁检测 (Threat Detection)
│   │   └── 访问控制 (Access Control)
│   ├── 认证系统 (auth-system) [增强]
│   │   ├── 多因子认证 (MFA)
│   │   ├── 权限管理 (RBAC Enhanced)
│   │   └── 安全审计 (Security Audit)
│   └── 数据库层 (database-layer) [扩展]
│       ├── 安全数据存储 (Security Data)
│       ├── 威胁情报库 (Threat Intelligence)
│       └── 审计日志 (Audit Logs)
├── 核心服务层 (Core Services) [新增安全服务]
│   ├── 文化智慧 (cultural-wisdom)
│   ├── 智能学习 (intelligent-learning)
│   ├── 轨迹记录 (trajectory-recording)
│   ├── 渗透测试服务 (penetration-testing) [新增]
│   ├── 威胁检测服务 (threat-detection) [新增]
│   ├── 安全教育服务 (security-education) [新增]
│   ├── 漏洞管理服务 (vulnerability-management) [新增]
│   └── 应急响应服务 (incident-response) [新增]
├── AI智能层 (AI Stack) [增强安全AI]
│   ├── 大语言模型 (LLMs)
│   │   ├── 安全知识问答 (Security Q&A)
│   │   └── 威胁分析 (Threat Analysis)
│   ├── 向量搜索 (Vector Search)
│   │   ├── 漏洞相似性检索 (Vuln Similarity)
│   │   └── 威胁情报匹配 (Threat Intel Match)
│   ├── 知识图谱 (Knowledge Graph)
│   │   ├── 攻击路径分析 (Attack Path)
│   │   └── 安全关系图谱 (Security Relations)
│   └── 机器学习 (Machine Learning) [新增]
│       ├── 异常检测 (Anomaly Detection)
│       ├── 恶意软件分类 (Malware Classification)
│       └── 行为分析 (Behavior Analysis)
└── 安全工具层 (Security Tools) [全新层级]
    ├── 扫描引擎 (Scanning Engines)
    │   ├── 网络扫描 (Network Scanning)
    │   ├── Web应用扫描 (Web App Scanning)
    │   └── 主机扫描 (Host Scanning)
    ├── 分析工具 (Analysis Tools)
    │   ├── 恶意软件分析 (Malware Analysis)
    │   ├── 流量分析 (Traffic Analysis)
    │   └── 日志分析 (Log Analysis)
    ├── 渗透工具 (Penetration Tools)
    │   ├── 漏洞利用 (Exploit Tools)
    │   ├── 后渗透 (Post-Exploitation)
    │   └── 社工工具 (Social Engineering)
    └── 防护工具 (Defense Tools)
        ├── 入侵检测 (Intrusion Detection)
        ├── 威胁狩猎 (Threat Hunting)
        └── 事件响应 (Incident Response)
```

## 🔧 核心服务详细设计

### 1. 渗透测试服务 (penetration-testing)

#### 服务架构
```go
// 渗透测试服务主结构
type PenetrationTestingService struct {
    // 核心组件
    authManager     *AuthorizationManager
    scanEngine      *VulnerabilityScanEngine
    exploitManager  *ExploitManager
    reportGenerator *ReportGenerator
    
    // 数据存储
    projectRepo     repository.ProjectRepository
    vulnRepo        repository.VulnerabilityRepository
    
    // 外部集成
    toolIntegrator  *SecurityToolIntegrator
    aiAnalyzer      *AIVulnerabilityAnalyzer
    
    // 配置和日志
    config          *config.Config
    logger          *logger.Logger
    auditor         *audit.Auditor
}

// 服务接口定义
type PenetrationTestingServiceInterface interface {
    // 项目管理
    CreateProject(ctx context.Context, req *CreateProjectRequest) (*Project, error)
    GetProject(ctx context.Context, projectID string) (*Project, error)
    UpdateProject(ctx context.Context, projectID string, req *UpdateProjectRequest) error
    DeleteProject(ctx context.Context, projectID string) error
    ListProjects(ctx context.Context, filter *ProjectFilter) ([]*Project, error)
    
    // 授权管理
    ValidateAuthorization(ctx context.Context, auth *Authorization) error
    CreateAuthorization(ctx context.Context, req *AuthorizationRequest) (*Authorization, error)
    
    // 扫描执行
    StartScan(ctx context.Context, projectID string, scanConfig *ScanConfig) (*ScanJob, error)
    GetScanStatus(ctx context.Context, jobID string) (*ScanStatus, error)
    StopScan(ctx context.Context, jobID string) error
    
    // 漏洞管理
    GetVulnerabilities(ctx context.Context, projectID string) ([]*Vulnerability, error)
    UpdateVulnerability(ctx context.Context, vulnID string, req *UpdateVulnRequest) error
    
    // 报告生成
    GenerateReport(ctx context.Context, projectID string, format string) (*Report, error)
    GetReport(ctx context.Context, reportID string) (*Report, error)
}
```

#### 数据模型设计
```go
// 渗透测试项目
type Project struct {
    ID              string                 `json:"id" gorm:"primaryKey"`
    Name            string                 `json:"name" gorm:"not null"`
    Description     string                 `json:"description"`
    ClientID        string                 `json:"client_id" gorm:"not null"`
    Authorization   Authorization          `json:"authorization" gorm:"embedded"`
    Scope           TestScope              `json:"scope" gorm:"embedded"`
    Timeline        Timeline               `json:"timeline" gorm:"embedded"`
    Team            []TeamMember           `json:"team" gorm:"many2many:project_team_members"`
    Status          ProjectStatus          `json:"status" gorm:"default:'created'"`
    Vulnerabilities []Vulnerability        `json:"vulnerabilities" gorm:"foreignKey:ProjectID"`
    Reports         []Report               `json:"reports" gorm:"foreignKey:ProjectID"`
    Metadata        map[string]interface{} `json:"metadata" gorm:"type:jsonb"`
    CreatedAt       time.Time              `json:"created_at"`
    UpdatedAt       time.Time              `json:"updated_at"`
    DeletedAt       *time.Time             `json:"deleted_at" gorm:"index"`
}

// 漏洞信息
type Vulnerability struct {
    ID              string                 `json:"id" gorm:"primaryKey"`
    ProjectID       string                 `json:"project_id" gorm:"not null"`
    VulnType        string                 `json:"vuln_type" gorm:"not null"`
    Severity        VulnerabilitySeverity  `json:"severity" gorm:"not null"`
    CVSS            float64                `json:"cvss"`
    CVE             string                 `json:"cve"`
    Title           string                 `json:"title" gorm:"not null"`
    Description     string                 `json:"description"`
    Impact          string                 `json:"impact"`
    Recommendation  string                 `json:"recommendation"`
    Evidence        []Evidence             `json:"evidence" gorm:"type:jsonb"`
    Status          VulnerabilityStatus    `json:"status" gorm:"default:'open'"`
    AssignedTo      string                 `json:"assigned_to"`
    FoundAt         time.Time              `json:"found_at"`
    FixedAt         *time.Time             `json:"fixed_at"`
    VerifiedAt      *time.Time             `json:"verified_at"`
    CreatedAt       time.Time              `json:"created_at"`
    UpdatedAt       time.Time              `json:"updated_at"`
}

// 扫描任务
type ScanJob struct {
    ID          string                 `json:"id" gorm:"primaryKey"`
    ProjectID   string                 `json:"project_id" gorm:"not null"`
    ScanType    string                 `json:"scan_type" gorm:"not null"`
    Config      ScanConfig             `json:"config" gorm:"type:jsonb"`
    Status      ScanJobStatus          `json:"status" gorm:"default:'pending'"`
    Progress    int                    `json:"progress" gorm:"default:0"`
    Results     map[string]interface{} `json:"results" gorm:"type:jsonb"`
    ErrorMsg    string                 `json:"error_msg"`
    StartedAt   *time.Time             `json:"started_at"`
    CompletedAt *time.Time             `json:"completed_at"`
    CreatedAt   time.Time              `json:"created_at"`
    UpdatedAt   time.Time              `json:"updated_at"`
}
```

### 2. 威胁检测服务 (threat-detection)

#### 服务架构
```go
// 威胁检测服务
type ThreatDetectionService struct {
    // 检测引擎
    ruleEngine      *RuleEngine
    mlEngine        *MachineLearningEngine
    behaviorEngine  *BehaviorAnalysisEngine
    
    // 数据处理
    eventProcessor  *EventProcessor
    alertManager    *AlertManager
    
    // 威胁情报
    threatIntel     *ThreatIntelligenceService
    iocManager      *IOCManager
    
    // 存储和缓存
    eventStore      repository.EventRepository
    alertStore      repository.AlertRepository
    cache           cache.Cache
    
    // 配置
    config          *config.Config
    logger          *logger.Logger
}

// 威胁检测接口
type ThreatDetectionServiceInterface interface {
    // 事件处理
    ProcessEvent(ctx context.Context, event *SecurityEvent) error
    ProcessEvents(ctx context.Context, events []*SecurityEvent) error
    
    // 规则管理
    CreateRule(ctx context.Context, rule *DetectionRule) error
    UpdateRule(ctx context.Context, ruleID string, rule *DetectionRule) error
    DeleteRule(ctx context.Context, ruleID string) error
    GetRules(ctx context.Context, filter *RuleFilter) ([]*DetectionRule, error)
    
    // 告警管理
    GetAlerts(ctx context.Context, filter *AlertFilter) ([]*Alert, error)
    UpdateAlert(ctx context.Context, alertID string, req *UpdateAlertRequest) error
    AcknowledgeAlert(ctx context.Context, alertID string, userID string) error
    
    // 威胁情报
    UpdateThreatIntel(ctx context.Context, intel *ThreatIntelligence) error
    QueryThreatIntel(ctx context.Context, query *ThreatIntelQuery) ([]*ThreatIntelligence, error)
    
    // 统计分析
    GetThreatStatistics(ctx context.Context, timeRange *TimeRange) (*ThreatStatistics, error)
    GetThreatTrends(ctx context.Context, timeRange *TimeRange) (*ThreatTrends, error)
}
```

#### 检测规则引擎
```go
// 检测规则
type DetectionRule struct {
    ID          string            `json:"id" gorm:"primaryKey"`
    Name        string            `json:"name" gorm:"not null"`
    Description string            `json:"description"`
    Category    string            `json:"category" gorm:"not null"`
    Severity    AlertSeverity     `json:"severity" gorm:"not null"`
    Conditions  []RuleCondition   `json:"conditions" gorm:"type:jsonb"`
    Actions     []RuleAction      `json:"actions" gorm:"type:jsonb"`
    Enabled     bool              `json:"enabled" gorm:"default:true"`
    Version     int               `json:"version" gorm:"default:1"`
    Tags        []string          `json:"tags" gorm:"type:jsonb"`
    CreatedBy   string            `json:"created_by"`
    CreatedAt   time.Time         `json:"created_at"`
    UpdatedAt   time.Time         `json:"updated_at"`
}

// 规则引擎
type RuleEngine struct {
    rules       map[string]*DetectionRule
    evaluator   *RuleEvaluator
    actionExec  *ActionExecutor
    metrics     *RuleMetrics
    logger      *logger.Logger
}

func (re *RuleEngine) EvaluateEvent(event *SecurityEvent) []*Alert {
    var alerts []*Alert
    
    for _, rule := range re.rules {
        if !rule.Enabled {
            continue
        }
        
        if re.evaluator.Evaluate(rule, event) {
            alert := re.createAlert(rule, event)
            alerts = append(alerts, alert)
            
            // 执行规则动作
            go re.actionExec.Execute(rule.Actions, alert)
            
            // 更新指标
            re.metrics.IncrementRuleHits(rule.ID)
        }
    }
    
    return alerts
}

// 规则条件评估器
type RuleEvaluator struct {
    operators map[string]OperatorFunc
}

type OperatorFunc func(fieldValue, ruleValue interface{}) bool

func (re *RuleEvaluator) Evaluate(rule *DetectionRule, event *SecurityEvent) bool {
    for i, condition := range rule.Conditions {
        result := re.evaluateCondition(condition, event)
        
        if i == 0 {
            // 第一个条件直接使用结果
            continue
        }
        
        // 根据逻辑操作符组合结果
        switch condition.LogicOp {
        case "AND":
            if !result {
                return false
            }
        case "OR":
            if result {
                return true
            }
        }
    }
    
    return true
}
```

### 3. 安全教育服务 (security-education)

#### 服务架构
```go
// 安全教育服务
type SecurityEducationService struct {
    // 内容管理
    contentManager  *ContentManager
    courseManager   *CourseManager
    labManager      *LabManager
    
    // 学习跟踪
    progressTracker *ProgressTracker
    assessmentMgr   *AssessmentManager
    
    // 虚拟环境
    labEnvironment  *LabEnvironment
    containerMgr    *ContainerManager
    
    // 数据存储
    contentRepo     repository.ContentRepository
    progressRepo    repository.ProgressRepository
    
    // 配置
    config          *config.Config
    logger          *logger.Logger
}

// 教育服务接口
type SecurityEducationServiceInterface interface {
    // 课程管理
    CreateCourse(ctx context.Context, course *Course) error
    GetCourse(ctx context.Context, courseID string) (*Course, error)
    UpdateCourse(ctx context.Context, courseID string, course *Course) error
    ListCourses(ctx context.Context, filter *CourseFilter) ([]*Course, error)
    
    // 实验环境
    CreateLab(ctx context.Context, lab *Lab) error
    StartLab(ctx context.Context, labID string, userID string) (*LabInstance, error)
    StopLab(ctx context.Context, instanceID string) error
    GetLabStatus(ctx context.Context, instanceID string) (*LabStatus, error)
    
    // 学习进度
    GetUserProgress(ctx context.Context, userID string) (*UserProgress, error)
    UpdateProgress(ctx context.Context, userID string, progress *ProgressUpdate) error
    
    // 评估测试
    CreateAssessment(ctx context.Context, assessment *Assessment) error
    SubmitAssessment(ctx context.Context, userID string, submission *AssessmentSubmission) (*AssessmentResult, error)
    GetAssessmentResults(ctx context.Context, userID string) ([]*AssessmentResult, error)
}
```

#### 虚拟实验环境
```go
// 实验环境管理
type LabEnvironment struct {
    containerMgr    *ContainerManager
    networkMgr      *NetworkManager
    resourceMgr     *ResourceManager
    securityMgr     *SecurityManager
}

// 实验实例
type LabInstance struct {
    ID              string                 `json:"id" gorm:"primaryKey"`
    LabID           string                 `json:"lab_id" gorm:"not null"`
    UserID          string                 `json:"user_id" gorm:"not null"`
    ContainerID     string                 `json:"container_id"`
    NetworkID       string                 `json:"network_id"`
    Status          LabInstanceStatus      `json:"status" gorm:"default:'creating'"`
    AccessURL       string                 `json:"access_url"`
    Credentials     map[string]string      `json:"credentials" gorm:"type:jsonb"`
    Resources       ResourceAllocation     `json:"resources" gorm:"embedded"`
    ExpiresAt       time.Time              `json:"expires_at"`
    CreatedAt       time.Time              `json:"created_at"`
    UpdatedAt       time.Time              `json:"updated_at"`
}

// 容器管理器
type ContainerManager struct {
    dockerClient    *docker.Client
    k8sClient       *kubernetes.Clientset
    imageRegistry   *ImageRegistry
    securityPolicy  *SecurityPolicy
}

func (cm *ContainerManager) CreateLabContainer(lab *Lab, userID string) (*LabInstance, error) {
    // 创建隔离的网络环境
    networkID, err := cm.createIsolatedNetwork(userID)
    if err != nil {
        return nil, fmt.Errorf("failed to create network: %w", err)
    }
    
    // 应用安全策略
    securityConfig := cm.securityPolicy.GetLabSecurityConfig(lab.SecurityLevel)
    
    // 创建容器
    containerConfig := &container.Config{
        Image:        lab.Image,
        Env:          lab.Environment,
        ExposedPorts: lab.Ports,
        Labels: map[string]string{
            "lab_id":    lab.ID,
            "user_id":   userID,
            "security":  string(lab.SecurityLevel),
        },
    }
    
    hostConfig := &container.HostConfig{
        NetworkMode:     container.NetworkMode(networkID),
        SecurityOpt:     securityConfig.SecurityOpts,
        CapDrop:         securityConfig.CapDrop,
        CapAdd:          securityConfig.CapAdd,
        ReadonlyRootfs:  securityConfig.ReadOnlyRootFS,
        Resources:       securityConfig.Resources,
    }
    
    resp, err := cm.dockerClient.ContainerCreate(
        context.Background(),
        containerConfig,
        hostConfig,
        nil,
        nil,
        "",
    )
    if err != nil {
        return nil, fmt.Errorf("failed to create container: %w", err)
    }
    
    // 启动容器
    if err := cm.dockerClient.ContainerStart(
        context.Background(),
        resp.ID,
        types.ContainerStartOptions{},
    ); err != nil {
        return nil, fmt.Errorf("failed to start container: %w", err)
    }
    
    // 创建实例记录
    instance := &LabInstance{
        ID:          generateInstanceID(),
        LabID:       lab.ID,
        UserID:      userID,
        ContainerID: resp.ID,
        NetworkID:   networkID,
        Status:      LabInstanceStatusRunning,
        ExpiresAt:   time.Now().Add(lab.MaxDuration),
        CreatedAt:   time.Now(),
    }
    
    return instance, nil
}
```

## 🔗 与现有系统集成

### 1. API网关集成

#### 安全路由配置
```go
// 安全相关路由配置
func (gw *APIGateway) setupSecurityRoutes() {
    // 渗透测试API
    pentestGroup := gw.router.Group("/api/v1/pentest")
    pentestGroup.Use(gw.authMiddleware.RequireRole("pentest_user"))
    pentestGroup.Use(gw.auditMiddleware.AuditSecurityOperation())
    {
        pentestGroup.POST("/projects", gw.pentestHandler.CreateProject)
        pentestGroup.GET("/projects/:id", gw.pentestHandler.GetProject)
        pentestGroup.POST("/projects/:id/scan", gw.pentestHandler.StartScan)
        pentestGroup.GET("/projects/:id/vulnerabilities", gw.pentestHandler.GetVulnerabilities)
    }
    
    // 威胁检测API
    threatGroup := gw.router.Group("/api/v1/threat")
    threatGroup.Use(gw.authMiddleware.RequireRole("security_analyst"))
    threatGroup.Use(gw.rateLimitMiddleware.Limit("threat_api", 100))
    {
        threatGroup.GET("/alerts", gw.threatHandler.GetAlerts)
        threatGroup.POST("/alerts/:id/acknowledge", gw.threatHandler.AcknowledgeAlert)
        threatGroup.GET("/statistics", gw.threatHandler.GetStatistics)
    }
    
    // 安全教育API
    eduGroup := gw.router.Group("/api/v1/security-education")
    eduGroup.Use(gw.authMiddleware.RequireAuthentication())
    {
        eduGroup.GET("/courses", gw.eduHandler.ListCourses)
        eduGroup.POST("/labs/:id/start", gw.eduHandler.StartLab)
        eduGroup.GET("/progress", gw.eduHandler.GetProgress)
    }
}

// 安全中间件
func (gw *APIGateway) securityMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 威胁检测
        if gw.threatDetector.IsThreateningRequest(c.Request) {
            gw.logger.Warn("Threatening request detected", 
                "ip", c.ClientIP(),
                "path", c.Request.URL.Path,
                "user_agent", c.Request.UserAgent(),
            )
            c.JSON(403, gin.H{"error": "Request blocked by security policy"})
            c.Abort()
            return
        }
        
        // 安全头设置
        c.Header("X-Content-Type-Options", "nosniff")
        c.Header("X-Frame-Options", "DENY")
        c.Header("X-XSS-Protection", "1; mode=block")
        c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
        
        c.Next()
    }
}
```

### 2. 认证系统增强

#### 多因子认证集成
```go
// 增强的认证服务
type EnhancedAuthService struct {
    baseAuthService *auth.AuthService
    mfaService      *MFAService
    riskAnalyzer    *RiskAnalyzer
    sessionManager  *SessionManager
}

// MFA服务
type MFAService struct {
    totpGenerator   *TOTPGenerator
    smsService      *SMSService
    emailService    *EmailService
    backupCodes     *BackupCodeManager
}

func (eas *EnhancedAuthService) AuthenticateWithMFA(
    ctx context.Context, 
    credentials *Credentials,
) (*AuthResult, error) {
    // 基础认证
    baseResult, err := eas.baseAuthService.Authenticate(ctx, credentials)
    if err != nil {
        return nil, err
    }
    
    // 风险评估
    riskLevel := eas.riskAnalyzer.AssessLoginRisk(ctx, &RiskContext{
        UserID:    baseResult.User.ID,
        IPAddress: credentials.IPAddress,
        UserAgent: credentials.UserAgent,
        Location:  credentials.Location,
    })
    
    // 根据风险级别决定是否需要MFA
    if riskLevel >= RiskLevelMedium || eas.requiresMFA(baseResult.User) {
        mfaChallenge, err := eas.mfaService.CreateChallenge(ctx, baseResult.User.ID)
        if err != nil {
            return nil, err
        }
        
        return &AuthResult{
            Status:       AuthStatusMFARequired,
            MFAChallenge: mfaChallenge,
            SessionToken: baseResult.SessionToken,
        }, nil
    }
    
    // 创建安全会话
    session, err := eas.sessionManager.CreateSecureSession(ctx, baseResult.User)
    if err != nil {
        return nil, err
    }
    
    return &AuthResult{
        Status:       AuthStatusSuccess,
        User:         baseResult.User,
        SessionToken: session.Token,
        ExpiresAt:    session.ExpiresAt,
    }, nil
}
```

### 3. 数据库层扩展

#### 安全数据模型
```sql
-- 安全相关数据表设计

-- 渗透测试项目表
CREATE TABLE pentest_projects (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    client_id UUID NOT NULL REFERENCES users(id),
    authorization JSONB NOT NULL,
    scope JSONB NOT NULL,
    timeline JSONB NOT NULL,
    status VARCHAR(50) DEFAULT 'created',
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deleted_at TIMESTAMP
);

-- 漏洞表
CREATE TABLE vulnerabilities (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    project_id UUID NOT NULL REFERENCES pentest_projects(id),
    vuln_type VARCHAR(100) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    cvss DECIMAL(3,1),
    cve VARCHAR(50),
    title VARCHAR(500) NOT NULL,
    description TEXT,
    impact TEXT,
    recommendation TEXT,
    evidence JSONB,
    status VARCHAR(50) DEFAULT 'open',
    assigned_to UUID REFERENCES users(id),
    found_at TIMESTAMP NOT NULL,
    fixed_at TIMESTAMP,
    verified_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 威胁检测规则表
CREATE TABLE threat_detection_rules (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    description TEXT,
    category VARCHAR(100) NOT NULL,
    severity VARCHAR(20) NOT NULL,
    conditions JSONB NOT NULL,
    actions JSONB NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    version INTEGER DEFAULT 1,
    tags JSONB,
    created_by UUID NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 安全告警表
CREATE TABLE security_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    rule_id UUID REFERENCES threat_detection_rules(id),
    title VARCHAR(500) NOT NULL,
    description TEXT,
    severity VARCHAR(20) NOT NULL,
    status VARCHAR(50) DEFAULT 'open',
    source_ip INET,
    target_ip INET,
    event_data JSONB,
    acknowledged_by UUID REFERENCES users(id),
    acknowledged_at TIMESTAMP,
    resolved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 安全事件表
CREATE TABLE security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR(100) NOT NULL,
    source VARCHAR(100) NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    source_ip INET,
    target_ip INET,
    user_id UUID REFERENCES users(id),
    event_data JSONB NOT NULL,
    processed BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 实验环境表
CREATE TABLE lab_instances (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    lab_id UUID NOT NULL,
    user_id UUID NOT NULL REFERENCES users(id),
    container_id VARCHAR(255),
    network_id VARCHAR(255),
    status VARCHAR(50) DEFAULT 'creating',
    access_url VARCHAR(500),
    credentials JSONB,
    resources JSONB,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_vulnerabilities_project_id ON vulnerabilities(project_id);
CREATE INDEX idx_vulnerabilities_severity ON vulnerabilities(severity);
CREATE INDEX idx_vulnerabilities_status ON vulnerabilities(status);
CREATE INDEX idx_security_alerts_severity ON security_alerts(severity);
CREATE INDEX idx_security_alerts_status ON security_alerts(status);
CREATE INDEX idx_security_alerts_created_at ON security_alerts(created_at);
CREATE INDEX idx_security_events_timestamp ON security_events(timestamp);
CREATE INDEX idx_security_events_event_type ON security_events(event_type);
CREATE INDEX idx_lab_instances_user_id ON lab_instances(user_id);
CREATE INDEX idx_lab_instances_status ON lab_instances(status);
```

## 🚀 部署和运维

### 1. 容器化部署

#### Docker配置
```dockerfile
# 渗透测试服务 Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN CGO_ENABLED=0 GOOS=linux go build -o pentest-service ./cmd/pentest-service

FROM alpine:latest
RUN apk --no-cache add ca-certificates nmap masscan
WORKDIR /root/

COPY --from=builder /app/pentest-service .
COPY --from=builder /app/configs ./configs

EXPOSE 8080
CMD ["./pentest-service"]
```

#### Kubernetes部署配置
```yaml
# 渗透测试服务部署配置
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pentest-service
  namespace: taishanglaojun-security
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pentest-service
  template:
    metadata:
      labels:
        app: pentest-service
    spec:
      containers:
      - name: pentest-service
        image: taishanglaojun/pentest-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
            add:
            - NET_RAW  # 用于网络扫描
        volumeMounts:
        - name: config-volume
          mountPath: /root/configs
      volumes:
      - name: config-volume
        configMap:
          name: pentest-config
---
apiVersion: v1
kind: Service
metadata:
  name: pentest-service
  namespace: taishanglaojun-security
spec:
  selector:
    app: pentest-service
  ports:
  - port: 80
    targetPort: 8080
  type: ClusterIP
```

### 2. 监控和告警

#### Prometheus监控配置
```yaml
# 安全服务监控配置
groups:
- name: security-services
  rules:
  - alert: HighVulnerabilityDetectionRate
    expr: rate(vulnerabilities_detected_total[5m]) > 10
    for: 2m
    labels:
      severity: warning
    annotations:
      summary: "High vulnerability detection rate"
      description: "Vulnerability detection rate is {{ $value }} per second"

  - alert: SecurityAlertBacklog
    expr: security_alerts_pending > 100
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "Security alert backlog is high"
      description: "There are {{ $value }} pending security alerts"

  - alert: LabEnvironmentResourceExhaustion
    expr: lab_instances_running / lab_instances_capacity > 0.9
    for: 1m
    labels:
      severity: warning
    annotations:
      summary: "Lab environment resources nearly exhausted"
      description: "Lab capacity utilization is {{ $value | humanizePercentage }}"
```

### 3. 安全加固

#### 网络安全策略
```yaml
# Kubernetes网络策略
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: security-services-policy
  namespace: taishanglaojun-security
spec:
  podSelector:
    matchLabels:
      tier: security
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: taishanglaojun-api
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: taishanglaojun-data
    ports:
    - protocol: TCP
      port: 5432  # PostgreSQL
    - protocol: TCP
      port: 6379  # Redis
  - to: []  # 允许DNS查询
    ports:
    - protocol: UDP
      port: 53
```

## 📊 性能和扩展性

### 1. 性能优化策略

#### 缓存策略
```go
// 多层缓存架构
type CacheManager struct {
    l1Cache    cache.Cache     // 本地缓存 (Redis)
    l2Cache    cache.Cache     // 分布式缓存 (Redis Cluster)
    cdnCache   cache.Cache     // CDN缓存
}

// 漏洞数据缓存
func (cm *CacheManager) GetVulnerabilityData(vulnID string) (*VulnerabilityData, error) {
    // L1缓存查询
    if data, found := cm.l1Cache.Get(vulnID); found {
        return data.(*VulnerabilityData), nil
    }
    
    // L2缓存查询
    if data, found := cm.l2Cache.Get(vulnID); found {
        // 回填L1缓存
        cm.l1Cache.Set(vulnID, data, 5*time.Minute)
        return data.(*VulnerabilityData), nil
    }
    
    // 从数据库加载
    data, err := cm.loadFromDatabase(vulnID)
    if err != nil {
        return nil, err
    }
    
    // 更新缓存
    cm.l2Cache.Set(vulnID, data, 30*time.Minute)
    cm.l1Cache.Set(vulnID, data, 5*time.Minute)
    
    return data, nil
}
```

#### 异步处理
```go
// 异步任务处理器
type AsyncTaskProcessor struct {
    taskQueue   chan Task
    workers     []*Worker
    resultStore storage.ResultStore
}

// 漏洞扫描异步处理
func (atp *AsyncTaskProcessor) ProcessScanTask(task *ScanTask) {
    go func() {
        defer func() {
            if r := recover(); r != nil {
                atp.handleTaskPanic(task, r)
            }
        }()
        
        result, err := atp.executeScan(task)
        if err != nil {
            atp.handleTaskError(task, err)
            return
        }
        
        // 存储结果
        atp.resultStore.Store(task.ID, result)
        
        // 发送通知
        atp.notifyTaskCompletion(task, result)
    }()
}
```

### 2. 水平扩展设计

#### 微服务拆分
```
安全模块微服务架构:
├── pentest-service (渗透测试服务)
├── threat-detection-service (威胁检测服务)
├── security-education-service (安全教育服务)
├── vulnerability-management-service (漏洞管理服务)
├── incident-response-service (应急响应服务)
├── threat-intelligence-service (威胁情报服务)
└── security-analytics-service (安全分析服务)
```

#### 负载均衡配置
```yaml
# Istio服务网格配置
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: security-services
spec:
  hosts:
  - security.taishanglaojun.com
  http:
  - match:
    - uri:
        prefix: /api/v1/pentest
    route:
    - destination:
        host: pentest-service
        subset: v1
      weight: 100
    fault:
      delay:
        percentage:
          value: 0.1
        fixedDelay: 5s
  - match:
    - uri:
        prefix: /api/v1/threat
    route:
    - destination:
        host: threat-detection-service
        subset: v1
      weight: 100
    retries:
      attempts: 3
      perTryTimeout: 2s
```

---

## 📝 总结

本技术架构设计文档详细描述了如何将黑帽与白帽安全功能模块集成到太上老君AI平台中。通过模块化设计、微服务架构、容器化部署等现代技术手段，确保安全功能与现有平台的无缝集成，同时保持系统的可扩展性、可维护性和安全性。

### 核心特点
1. **深度集成**: 与现有S×C×T三轴体系深度融合
2. **模块化设计**: 松耦合的微服务架构
3. **安全优先**: 全方位的安全防护措施
4. **可扩展性**: 支持水平扩展和性能优化
5. **合规性**: 严格遵守法律法规和行业标准

### 下一步计划
1. 完成详细的实施计划制定
2. 开始核心模块的开发工作
3. 建立完善的测试和部署流程
4. 制定运维和监控策略

---

**文档版本**: v1.0  
**创建时间**: 2025年1月  
**最后更新**: 2025年1月  
**创建人员**: Li da  
**维护团队**: 源界-突击队