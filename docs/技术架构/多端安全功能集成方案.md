# 太上老君AI平台 - 多端安全功能集成方案

## 📋 概述

本文档详细描述了太上老君AI平台安全模块在多个终端平台的功能衔接和部署方案，包括Web端、桌面端（Windows/macOS/Linux）、移动端（Android/iOS/HarmonyOS）和手表端（Apple Watch/Wear OS）的完整实现策略。

## 🎯 多端架构设计原则

### 核心设计理念
- **功能分层**: 根据设备能力分层实现安全功能
- **体验一致**: 保持跨平台的用户体验一致性
- **性能优化**: 针对不同设备性能特点优化
- **安全优先**: 确保所有平台的安全性

### 技术架构原则
- **API统一**: 所有平台共享统一的后端API
- **数据同步**: 实现跨设备的数据实时同步
- **离线支持**: 关键功能支持离线操作
- **渐进增强**: 根据设备能力渐进增强功能

## 🏗️ 整体架构设计

### 多端架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    太上老君AI平台 - 多端安全架构                    │
├─────────────────────────────────────────────────────────────┤
│  终端层 (Client Layer)                                        │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐    │
│  │   Web端     │   桌面端     │   移动端     │   手表端     │    │
│  │  (React)    │ (Electron/  │ (Flutter/   │ (WatchOS/   │    │
│  │             │  Tauri)     │  Native)    │  WearOS)    │    │
│  └─────────────┴─────────────┴─────────────┴─────────────┘    │
├─────────────────────────────────────────────────────────────┤
│  API网关层 (API Gateway Layer)                                │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │  统一API网关 + 设备适配中间件 + 安全认证                      │  │
│  └─────────────────────────────────────────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│  业务服务层 (Business Service Layer)                          │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐    │
│  │  渗透测试    │  威胁检测    │  安全教育    │  漏洞管理    │    │
│  │   服务      │    服务     │    服务     │    服务     │    │
│  └─────────────┴─────────────┴─────────────┴─────────────┘    │
├─────────────────────────────────────────────────────────────┤
│  数据存储层 (Data Storage Layer)                              │
│  ┌─────────────┬─────────────┬─────────────┬─────────────┐    │
│  │ PostgreSQL  │  MongoDB    │   Redis     │   Neo4j     │    │
│  │  (关系数据)  │ (文档数据)   │  (缓存)     │ (知识图谱)   │    │
│  └─────────────┴─────────────┴─────────────┴─────────────┘    │
└─────────────────────────────────────────────────────────────┘
```

### 功能分层策略

#### 功能层级定义
```
L4 - 完整功能层 (Web端、桌面端)
├── 渗透测试项目管理
├── 完整威胁检测仪表板
├── 高级安全分析
├── 详细报告生成
└── 管理员功能

L3 - 核心功能层 (移动端)
├── 基础渗透测试
├── 威胁监控
├── 安全教育
└── 简化报告

L2 - 监控功能层 (手表端)
├── 威胁告警
├── 安全状态
├── 快速响应
└── 基础通知

L1 - 通知功能层 (IoT设备)
├── 安全告警
├── 状态指示
└── 紧急通知
```

## 📱 各端详细实现方案

### 1. Web端 - 完整功能实现

#### 1.1 技术栈和架构

**前端技术栈**:
```typescript
// 基于现有Web应用扩展
{
  "framework": "React 18 + TypeScript",
  "bundler": "Vite",
  "styling": "Tailwind CSS",
  "state": "Zustand + React Query",
  "routing": "React Router v6",
  "charts": "Chart.js + D3.js",
  "security": "专用安全组件库"
}
```

**安全模块组件架构**:
```typescript
// src/modules/security/index.ts
export const SecurityModule = {
  // 渗透测试模块
  PentestModule: {
    ProjectManagement: () => import('./pentest/ProjectManagement'),
    ScanDashboard: () => import('./pentest/ScanDashboard'),
    VulnerabilityAnalysis: () => import('./pentest/VulnerabilityAnalysis'),
    ReportGeneration: () => import('./pentest/ReportGeneration')
  },
  
  // 威胁检测模块
  ThreatDetectionModule: {
    RealTimeMonitoring: () => import('./threat/RealTimeMonitoring'),
    AlertManagement: () => import('./threat/AlertManagement'),
    ThreatIntelligence: () => import('./threat/ThreatIntelligence'),
    IncidentResponse: () => import('./threat/IncidentResponse')
  },
  
  // 安全教育模块
  SecurityEducationModule: {
    CourseCatalog: () => import('./education/CourseCatalog'),
    VirtualLab: () => import('./education/VirtualLab'),
    CTFPlatform: () => import('./education/CTFPlatform'),
    ProgressTracking: () => import('./education/ProgressTracking')
  },
  
  // 安全管理模块
  SecurityManagementModule: {
    UserManagement: () => import('./management/UserManagement'),
    PolicyManagement: () => import('./management/PolicyManagement'),
    AuditLogs: () => import('./management/AuditLogs'),
    ComplianceReports: () => import('./management/ComplianceReports')
  }
};
```

**核心安全组件实现**:
```typescript
// src/modules/security/components/PentestDashboard.tsx
import React, { useState, useEffect } from 'react';
import { useSecurityStore } from '../stores/securityStore';
import { PentestProject, ScanJob, Vulnerability } from '../types';

interface PentestDashboardProps {
  projectId?: string;
}

export const PentestDashboard: React.FC<PentestDashboardProps> = ({ projectId }) => {
  const { 
    projects, 
    scanJobs, 
    vulnerabilities,
    fetchProjects,
    startScan,
    stopScan 
  } = useSecurityStore();

  const [selectedProject, setSelectedProject] = useState<PentestProject | null>(null);
  const [activeScan, setActiveScan] = useState<ScanJob | null>(null);

  useEffect(() => {
    fetchProjects();
  }, []);

  const handleStartScan = async (scanConfig: ScanConfig) => {
    if (!selectedProject) return;
    
    try {
      const scanJob = await startScan(selectedProject.id, scanConfig);
      setActiveScan(scanJob);
    } catch (error) {
      console.error('Failed to start scan:', error);
    }
  };

  return (
    <div className="pentest-dashboard">
      {/* 项目选择器 */}
      <ProjectSelector 
        projects={projects}
        selectedProject={selectedProject}
        onProjectSelect={setSelectedProject}
      />
      
      {/* 扫描控制面板 */}
      <ScanControlPanel
        project={selectedProject}
        activeScan={activeScan}
        onStartScan={handleStartScan}
        onStopScan={() => stopScan(activeScan?.id)}
      />
      
      {/* 实时结果展示 */}
      <RealTimeResults
        scanJob={activeScan}
        vulnerabilities={vulnerabilities}
      />
      
      {/* 漏洞分析图表 */}
      <VulnerabilityCharts
        vulnerabilities={vulnerabilities}
        timeRange="24h"
      />
    </div>
  );
};
```

**安全状态管理**:
```typescript
// src/modules/security/stores/securityStore.ts
import { create } from 'zustand';
import { SecurityAPI } from '../api/securityAPI';

interface SecurityState {
  // 渗透测试状态
  projects: PentestProject[];
  scanJobs: ScanJob[];
  vulnerabilities: Vulnerability[];
  
  // 威胁检测状态
  threats: ThreatAlert[];
  detectionRules: DetectionRule[];
  incidents: SecurityIncident[];
  
  // 安全教育状态
  courses: SecurityCourse[];
  labEnvironments: LabEnvironment[];
  userProgress: LearningProgress[];
  
  // 操作方法
  fetchProjects: () => Promise<void>;
  createProject: (project: CreateProjectRequest) => Promise<PentestProject>;
  startScan: (projectId: string, config: ScanConfig) => Promise<ScanJob>;
  stopScan: (scanId: string) => Promise<void>;
  
  fetchThreats: () => Promise<void>;
  acknowledgeAlert: (alertId: string) => Promise<void>;
  createIncident: (incident: CreateIncidentRequest) => Promise<SecurityIncident>;
}

export const useSecurityStore = create<SecurityState>((set, get) => ({
  // 初始状态
  projects: [],
  scanJobs: [],
  vulnerabilities: [],
  threats: [],
  detectionRules: [],
  incidents: [],
  courses: [],
  labEnvironments: [],
  userProgress: [],
  
  // 渗透测试操作
  fetchProjects: async () => {
    try {
      const projects = await SecurityAPI.pentest.getProjects();
      set({ projects });
    } catch (error) {
      console.error('Failed to fetch projects:', error);
    }
  },
  
  createProject: async (projectData) => {
    try {
      const project = await SecurityAPI.pentest.createProject(projectData);
      set(state => ({ 
        projects: [...state.projects, project] 
      }));
      return project;
    } catch (error) {
      console.error('Failed to create project:', error);
      throw error;
    }
  },
  
  startScan: async (projectId, config) => {
    try {
      const scanJob = await SecurityAPI.pentest.startScan(projectId, config);
      set(state => ({ 
        scanJobs: [...state.scanJobs, scanJob] 
      }));
      return scanJob;
    } catch (error) {
      console.error('Failed to start scan:', error);
      throw error;
    }
  },
  
  // 威胁检测操作
  fetchThreats: async () => {
    try {
      const threats = await SecurityAPI.threat.getAlerts();
      set({ threats });
    } catch (error) {
      console.error('Failed to fetch threats:', error);
    }
  },
  
  acknowledgeAlert: async (alertId) => {
    try {
      await SecurityAPI.threat.acknowledgeAlert(alertId);
      set(state => ({
        threats: state.threats.map(threat => 
          threat.id === alertId 
            ? { ...threat, status: 'acknowledged' }
            : threat
        )
      }));
    } catch (error) {
      console.error('Failed to acknowledge alert:', error);
    }
  }
}));
```

#### 1.2 Web端部署配置

**Docker配置**:
```dockerfile
# frontend/web-app/Dockerfile.security
FROM node:18-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build:security

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
COPY nginx.security.conf /etc/nginx/conf.d/default.conf

# 安全配置
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001
USER nextjs

EXPOSE 3000
CMD ["nginx", "-g", "daemon off;"]
```

**Nginx安全配置**:
```nginx
# nginx.security.conf
server {
    listen 3000;
    server_name localhost;
    
    # 安全头设置
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;
    
    # 静态资源
    location / {
        root /usr/share/nginx/html;
        try_files $uri $uri/ /index.html;
        
        # 缓存策略
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
    
    # API代理
    location /api/ {
        proxy_pass http://api-gateway:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 安全配置
        proxy_hide_header X-Powered-By;
        proxy_set_header X-Content-Type-Options nosniff;
    }
}
```

### 2. 桌面端 - 跨平台实现

#### 2.1 技术选型和架构

**技术栈对比**:
```typescript
// 桌面端技术选型
const DesktopTechStack = {
  // 方案1: Electron (推荐)
  Electron: {
    advantages: ['Web技术复用', '快速开发', '丰富生态'],
    disadvantages: ['资源占用大', '性能相对较低'],
    suitability: '适合快速开发和Web技术复用'
  },
  
  // 方案2: Tauri (性能优先)
  Tauri: {
    advantages: ['性能优秀', '资源占用小', '安全性高'],
    disadvantages: ['学习成本高', '生态相对较小'],
    suitability: '适合性能要求高的场景'
  },
  
  // 方案3: 原生开发
  Native: {
    advantages: ['性能最佳', '系统集成度高'],
    disadvantages: ['开发成本高', '维护复杂'],
    suitability: '适合特定平台深度集成'
  }
};
```

**推荐架构 - Electron + Tauri混合方案**:
```typescript
// desktop-apps/shared/architecture.ts
export interface DesktopSecurityArchitecture {
  // 主进程 (Electron/Tauri)
  mainProcess: {
    securityManager: SecurityManager;
    systemIntegration: SystemIntegration;
    processManager: ProcessManager;
  };
  
  // 渲染进程 (Web技术)
  rendererProcess: {
    securityUI: SecurityUIComponents;
    dataManager: DataManager;
    communicationBridge: IPCBridge;
  };
  
  // 原生模块 (性能关键部分)
  nativeModules: {
    networkScanner: NativeNetworkScanner;
    systemMonitor: NativeSystemMonitor;
    cryptoEngine: NativeCryptoEngine;
  };
}
```

#### 2.2 Windows桌面端实现

**Electron主进程实现**:
```typescript
// desktop-apps/windows/src/main/securityMain.ts
import { app, BrowserWindow, ipcMain, dialog } from 'electron';
import { SecurityManager } from './security/SecurityManager';
import { SystemIntegration } from './system/SystemIntegration';

class SecurityDesktopApp {
  private mainWindow: BrowserWindow | null = null;
  private securityManager: SecurityManager;
  private systemIntegration: SystemIntegration;

  constructor() {
    this.securityManager = new SecurityManager();
    this.systemIntegration = new SystemIntegration();
    this.setupIPC();
  }

  async createMainWindow(): Promise<void> {
    this.mainWindow = new BrowserWindow({
      width: 1400,
      height: 900,
      webPreferences: {
        nodeIntegration: false,
        contextIsolation: true,
        enableRemoteModule: false,
        preload: path.join(__dirname, 'preload.js')
      },
      // 安全配置
      show: false,
      titleBarStyle: 'default',
      webSecurity: true
    });

    // 加载安全模块界面
    if (isDev) {
      await this.mainWindow.loadURL('http://localhost:3000/security');
    } else {
      await this.mainWindow.loadFile('dist/security/index.html');
    }

    // 安全事件监听
    this.mainWindow.webContents.on('new-window', this.handleNewWindow);
    this.mainWindow.webContents.on('will-navigate', this.handleNavigation);
    
    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow?.show();
    });
  }

  private setupIPC(): void {
    // 渗透测试IPC
    ipcMain.handle('pentest:start-scan', async (event, scanConfig) => {
      try {
        return await this.securityManager.startPentestScan(scanConfig);
      } catch (error) {
        throw new Error(`Scan failed: ${error.message}`);
      }
    });

    // 系统集成IPC
    ipcMain.handle('system:get-network-interfaces', async () => {
      return await this.systemIntegration.getNetworkInterfaces();
    });

    // 威胁检测IPC
    ipcMain.handle('threat:start-monitoring', async (event, config) => {
      return await this.securityManager.startThreatMonitoring(config);
    });

    // 文件操作IPC (安全限制)
    ipcMain.handle('file:select-target-file', async () => {
      const result = await dialog.showOpenDialog(this.mainWindow!, {
        properties: ['openFile'],
        filters: [
          { name: 'Target Files', extensions: ['txt', 'json', 'xml'] }
        ]
      });
      
      if (!result.canceled && result.filePaths.length > 0) {
        // 安全检查
        const filePath = result.filePaths[0];
        if (await this.securityManager.validateFilePath(filePath)) {
          return filePath;
        }
      }
      return null;
    });
  }

  private handleNewWindow = (event: Event, url: string) => {
    event.preventDefault();
    // 只允许安全的外部链接
    if (this.securityManager.isAllowedURL(url)) {
      shell.openExternal(url);
    }
  };

  private handleNavigation = (event: Event, url: string) => {
    // 限制导航到安全域名
    if (!this.securityManager.isAllowedNavigation(url)) {
      event.preventDefault();
    }
  };
}
```

**原生安全模块**:
```cpp
// desktop-apps/windows/src/native/NetworkScanner.cpp
#include "NetworkScanner.h"
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>

class WindowsNetworkScanner : public NetworkScanner {
private:
    std::vector<NetworkInterface> interfaces;
    std::mutex scanMutex;

public:
    std::vector<NetworkInterface> getNetworkInterfaces() override {
        std::lock_guard<std::mutex> lock(scanMutex);
        
        ULONG bufferSize = 0;
        GetAdaptersAddresses(AF_UNSPEC, 0, nullptr, nullptr, &bufferSize);
        
        std::vector<char> buffer(bufferSize);
        PIP_ADAPTER_ADDRESSES adapters = 
            reinterpret_cast<PIP_ADAPTER_ADDRESSES>(buffer.data());
        
        if (GetAdaptersAddresses(AF_UNSPEC, 0, nullptr, adapters, &bufferSize) 
            == ERROR_SUCCESS) {
            
            interfaces.clear();
            for (auto adapter = adapters; adapter; adapter = adapter->Next) {
                NetworkInterface iface;
                iface.name = adapter->AdapterName;
                iface.description = adapter->Description;
                iface.isUp = (adapter->OperStatus == IfOperStatusUp);
                
                // 获取IP地址
                for (auto addr = adapter->FirstUnicastAddress; addr; addr = addr->Next) {
                    char ipStr[INET6_ADDRSTRLEN];
                    if (addr->Address.lpSockaddr->sa_family == AF_INET) {
                        inet_ntop(AF_INET, 
                            &((sockaddr_in*)addr->Address.lpSockaddr)->sin_addr,
                            ipStr, INET_ADDRSTRLEN);
                        iface.ipv4Addresses.push_back(ipStr);
                    }
                }
                
                interfaces.push_back(iface);
            }
        }
        
        return interfaces;
    }

    ScanResult performPortScan(const std::string& target, 
                              const std::vector<int>& ports) override {
        std::lock_guard<std::mutex> lock(scanMutex);
        
        ScanResult result;
        result.target = target;
        result.startTime = std::chrono::system_clock::now();
        
        // 并行端口扫描
        std::vector<std::future<PortScanResult>> futures;
        
        for (int port : ports) {
            futures.push_back(std::async(std::launch::async, [this, target, port]() {
                return this->scanPort(target, port);
            }));
        }
        
        // 收集结果
        for (auto& future : futures) {
            auto portResult = future.get();
            if (portResult.isOpen) {
                result.openPorts.push_back(portResult);
            }
        }
        
        result.endTime = std::chrono::system_clock::now();
        return result;
    }

private:
    PortScanResult scanPort(const std::string& target, int port) {
        PortScanResult result;
        result.port = port;
        result.isOpen = false;
        
        SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock == INVALID_SOCKET) {
            return result;
        }
        
        // 设置超时
        DWORD timeout = 1000; // 1秒
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, 
                  (char*)&timeout, sizeof(timeout));
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, 
                  (char*)&timeout, sizeof(timeout));
        
        sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        inet_pton(AF_INET, target.c_str(), &addr.sin_addr);
        
        if (connect(sock, (sockaddr*)&addr, sizeof(addr)) == 0) {
            result.isOpen = true;
            
            // 尝试获取服务信息
            char buffer[1024];
            int received = recv(sock, buffer, sizeof(buffer) - 1, 0);
            if (received > 0) {
                buffer[received] = '\0';
                result.serviceInfo = buffer;
            }
        }
        
        closesocket(sock);
        return result;
    }
};
```

#### 2.3 macOS桌面端实现

**Swift原生集成**:
```swift
// desktop-apps/macos/Sources/Security/SecurityManager.swift
import Foundation
import Network
import SystemConfiguration

@objc class SecurityManager: NSObject {
    private let networkMonitor = NWPathMonitor()
    private let queue = DispatchQueue(label: "security.monitor")
    
    @objc func startNetworkMonitoring() {
        networkMonitor.pathUpdateHandler = { [weak self] path in
            self?.handleNetworkChange(path)
        }
        networkMonitor.start(queue: queue)
    }
    
    private func handleNetworkChange(_ path: NWPath) {
        // 网络变化安全检查
        if path.status == .satisfied {
            checkNetworkSecurity()
        }
    }
    
    @objc func performPortScan(target: String, ports: [Int], 
                              completion: @escaping ([String: Any]) -> Void) {
        queue.async {
            var results: [String: Any] = [:]
            var openPorts: [Int] = []
            
            let group = DispatchGroup()
            
            for port in ports {
                group.enter()
                self.scanPort(target: target, port: port) { isOpen in
                    if isOpen {
                        openPorts.append(port)
                    }
                    group.leave()
                }
            }
            
            group.notify(queue: .main) {
                results["target"] = target
                results["openPorts"] = openPorts
                results["timestamp"] = Date().timeIntervalSince1970
                completion(results)
            }
        }
    }
    
    private func scanPort(target: String, port: Int, 
                         completion: @escaping (Bool) -> Void) {
        let connection = NWConnection(
            host: NWEndpoint.Host(target),
            port: NWEndpoint.Port(integerLiteral: UInt16(port)),
            using: .tcp
        )
        
        connection.stateUpdateHandler = { state in
            switch state {
            case .ready:
                completion(true)
                connection.cancel()
            case .failed(_):
                completion(false)
            default:
                break
            }
        }
        
        connection.start(queue: queue)
        
        // 超时处理
        DispatchQueue.global().asyncAfter(deadline: .now() + 2.0) {
            if connection.state != .ready {
                completion(false)
                connection.cancel()
            }
        }
    }
    
    @objc func getSystemSecurityInfo() -> [String: Any] {
        var info: [String: Any] = [:]
        
        // 获取系统版本
        let version = ProcessInfo.processInfo.operatingSystemVersion
        info["osVersion"] = "\(version.majorVersion).\(version.minorVersion).\(version.patchVersion)"
        
        // 获取网络接口
        info["networkInterfaces"] = getNetworkInterfaces()
        
        // 获取安全状态
        info["securityStatus"] = getSecurityStatus()
        
        return info
    }
    
    private func getNetworkInterfaces() -> [[String: Any]] {
        var interfaces: [[String: Any]] = []
        
        var ifaddr: UnsafeMutablePointer<ifaddrs>?
        guard getifaddrs(&ifaddr) == 0 else { return interfaces }
        defer { freeifaddrs(ifaddr) }
        
        var ptr = ifaddr
        while ptr != nil {
            defer { ptr = ptr?.pointee.ifa_next }
            
            guard let interface = ptr?.pointee else { continue }
            let name = String(cString: interface.ifa_name)
            
            if interface.ifa_addr.pointee.sa_family == UInt8(AF_INET) {
                var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
                getnameinfo(interface.ifa_addr, socklen_t(interface.ifa_addr.pointee.sa_len),
                           &hostname, socklen_t(hostname.count),
                           nil, socklen_t(0), NI_NUMERICHOST)
                
                let address = String(cString: hostname)
                interfaces.append([
                    "name": name,
                    "address": address,
                    "family": "IPv4"
                ])
            }
        }
        
        return interfaces
    }
    
    private func getSecurityStatus() -> [String: Any] {
        return [
            "firewallEnabled": isFirewallEnabled(),
            "systemIntegrityProtection": isSIPEnabled(),
            "gatekeeper": isGatekeeperEnabled()
        ]
    }
    
    private func isFirewallEnabled() -> Bool {
        // 检查防火墙状态
        let task = Process()
        task.launchPath = "/usr/libexec/ApplicationFirewall/socketfilterfw"
        task.arguments = ["--getglobalstate"]
        
        let pipe = Pipe()
        task.standardOutput = pipe
        task.launch()
        task.waitUntilExit()
        
        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(data: data, encoding: .utf8) ?? ""
        
        return output.contains("enabled")
    }
    
    private func isSIPEnabled() -> Bool {
        // 检查系统完整性保护
        let task = Process()
        task.launchPath = "/usr/bin/csrutil"
        task.arguments = ["status"]
        
        let pipe = Pipe()
        task.standardOutput = pipe
        task.launch()
        task.waitUntilExit()
        
        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(data: data, encoding: .utf8) ?? ""
        
        return output.contains("enabled")
    }
    
    private func isGatekeeperEnabled() -> Bool {
        // 检查Gatekeeper状态
        let task = Process()
        task.launchPath = "/usr/sbin/spctl"
        task.arguments = ["--status"]
        
        let pipe = Pipe()
        task.standardOutput = pipe
        task.launch()
        task.waitUntilExit()
        
        let data = pipe.fileHandleForReading.readDataToEndOfFile()
        let output = String(data: data, encoding: .utf8) ?? ""
        
        return output.contains("enabled")
    }
}
```

#### 2.4 Linux桌面端实现

**C++原生模块**:
```cpp
// desktop-apps/linux/src/SecurityModule.cpp
#include "SecurityModule.h"
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <ifaddrs.h>
#include <thread>
#include <future>

class LinuxSecurityModule : public SecurityModule {
private:
    std::atomic<bool> isMonitoring{false};
    std::thread monitoringThread;

public:
    bool startSystemMonitoring() override {
        if (isMonitoring.load()) {
            return false;
        }
        
        isMonitoring.store(true);
        monitoringThread = std::thread(&LinuxSecurityModule::monitoringLoop, this);
        
        return true;
    }
    
    void stopSystemMonitoring() override {
        isMonitoring.store(false);
        if (monitoringThread.joinable()) {
            monitoringThread.join();
        }
    }
    
    std::vector<NetworkInterface> getNetworkInterfaces() override {
        std::vector<NetworkInterface> interfaces;
        
        struct ifaddrs *ifaddr, *ifa;
        if (getifaddrs(&ifaddr) == -1) {
            return interfaces;
        }
        
        for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
            if (ifa->ifa_addr == nullptr) continue;
            
            if (ifa->ifa_addr->sa_family == AF_INET) {
                NetworkInterface iface;
                iface.name = ifa->ifa_name;
                
                char host[NI_MAXHOST];
                int result = getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in),
                                       host, NI_MAXHOST, nullptr, 0, NI_NUMERICHOST);
                
                if (result == 0) {
                    iface.ipAddress = host;
                    iface.isUp = (ifa->ifa_flags & IFF_UP) != 0;
                    interfaces.push_back(iface);
                }
            }
        }
        
        freeifaddrs(ifaddr);
        return interfaces;
    }
    
    ScanResult performPortScan(const std::string& target, 
                              const std::vector<int>& ports) override {
        ScanResult result;
        result.target = target;
        result.startTime = std::chrono::system_clock::now();
        
        // 并行扫描
        std::vector<std::future<bool>> futures;
        std::vector<int> openPorts;
        std::mutex resultMutex;
        
        for (int port : ports) {
            futures.push_back(std::async(std::launch::async, [&, port]() {
                bool isOpen = scanSinglePort(target, port);
                if (isOpen) {
                    std::lock_guard<std::mutex> lock(resultMutex);
                    openPorts.push_back(port);
                }
                return isOpen;
            }));
        }
        
        // 等待所有扫描完成
        for (auto& future : futures) {
            future.wait();
        }
        
        result.openPorts = openPorts;
        result.endTime = std::chrono::system_clock::now();
        
        return result;
    }
    
    SystemSecurityInfo getSystemSecurityInfo() override {
        SystemSecurityInfo info;
        
        // 获取系统信息
        info.osVersion = getOSVersion();
        info.kernelVersion = getKernelVersion();
        
        // 检查安全功能
        info.firewallStatus = checkFirewallStatus();
        info.selinuxStatus = checkSELinuxStatus();
        info.appArmorStatus = checkAppArmorStatus();
        
        // 获取网络信息
        info.networkInterfaces = getNetworkInterfaces();
        
        return info;
    }

private:
    void monitoringLoop() {
        while (isMonitoring.load()) {
            // 监控系统安全状态
            monitorProcesses();
            monitorNetworkConnections();
            monitorFileSystemChanges();
            
            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }
    
    bool scanSinglePort(const std::string& target, int port) {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0) {
            return false;
        }
        
        // 设置超时
        struct timeval timeout;
        timeout.tv_sec = 2;
        timeout.tv_usec = 0;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
        
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        inet_pton(AF_INET, target.c_str(), &addr.sin_addr);
        
        bool isOpen = (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0);
        
        close(sock);
        return isOpen;
    }
    
    std::string getOSVersion() {
        std::ifstream file("/etc/os-release");
        std::string line;
        while (std::getline(file, line)) {
            if (line.find("PRETTY_NAME=") == 0) {
                return line.substr(13, line.length() - 14); // 去掉引号
            }
        }
        return "Unknown";
    }
    
    std::string getKernelVersion() {
        std::ifstream file("/proc/version");
        std::string version;
        std::getline(file, version);
        return version;
    }
    
    bool checkFirewallStatus() {
        // 检查iptables状态
        int result = system("iptables -L > /dev/null 2>&1");
        return WEXITSTATUS(result) == 0;
    }
    
    bool checkSELinuxStatus() {
        std::ifstream file("/sys/fs/selinux/enforce");
        if (file.is_open()) {
            std::string status;
            std::getline(file, status);
            return status == "1";
        }
        return false;
    }
    
    bool checkAppArmorStatus() {
        int result = system("aa-status > /dev/null 2>&1");
        return WEXITSTATUS(result) == 0;
    }
    
    void monitorProcesses() {
        // 监控可疑进程
        // 实现进程监控逻辑
    }
    
    void monitorNetworkConnections() {
        // 监控网络连接
        // 实现网络监控逻辑
    }
    
    void monitorFileSystemChanges() {
        // 监控文件系统变化
        // 实现文件监控逻辑
    }
};
```

### 3. 移动端 - 轻量化实现

#### 3.1 Flutter跨平台实现

**Flutter安全模块架构**:
```dart
// mobile-apps/shared/lib/modules/security/security_module.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

class SecurityModule extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => SecurityProvider()),
        ChangeNotifierProvider(create: (_) => ThreatMonitorProvider()),
        ChangeNotifierProvider(create: (_) => EducationProvider()),
      ],
      child: SecurityApp(),
    );
  }
}

class SecurityApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: '太上老君安全',
      theme: SecurityTheme.lightTheme,
      darkTheme: SecurityTheme.darkTheme,
      home: SecurityDashboard(),
      routes: {
        '/security/dashboard': (context) => SecurityDashboard(),
        '/security/threats': (context) => ThreatMonitorScreen(),
        '/security/education': (context) => SecurityEducationScreen(),
        '/security/scan': (context) => QuickScanScreen(),
        '/security/settings': (context) => SecuritySettingsScreen(),
      },
    );
  }
}
```

**安全仪表板实现**:
```dart
// mobile-apps/shared/lib/screens/security_dashboard.dart
class SecurityDashboard extends StatefulWidget {
  @override
  _SecurityDashboardState createState() => _SecurityDashboardState();
}

class _SecurityDashboardState extends State<SecurityDashboard> {
  late SecurityProvider securityProvider;
  late ThreatMonitorProvider threatProvider;

  @override
  void initState() {
    super.initState();
    securityProvider = Provider.of<SecurityProvider>(context, listen: false);
    threatProvider = Provider.of<ThreatMonitorProvider>(context, listen: false);
    
    _initializeSecurity();
  }

  Future<void> _initializeSecurity() async {
    await securityProvider.initialize();
    await threatProvider.startMonitoring();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('安全中心'),
        actions: [
          IconButton(
            icon: Icon(Icons.notifications),
            onPressed: () => _showNotifications(),
          ),
          IconButton(
            icon: Icon(Icons.settings),
            onPressed: () => Navigator.pushNamed(context, '/security/settings'),
          ),
        ],
      ),
      body: Consumer2<SecurityProvider, ThreatMonitorProvider>(
        builder: (context, security, threat, child) {
          return RefreshIndicator(
            onRefresh: _refreshData,
            child: ListView(
              padding: EdgeInsets.all(16),
              children: [
                // 安全状态卡片
                SecurityStatusCard(
                  status: security.overallStatus,
                  lastScan: security.lastScanTime,
                  threatsDetected: threat.activeThreats.length,
                ),
                
                SizedBox(height: 16),
                
                // 快速操作
                QuickActionsGrid(
                  onQuickScan: () => _performQuickScan(),
                  onThreatCheck: () => _checkThreats(),
                  onEducation: () => Navigator.pushNamed(context, '/security/education'),
                  onSettings: () => Navigator.pushNamed(context, '/security/settings'),
                ),
                
                SizedBox(height: 16),
                
                // 威胁概览
                ThreatOverviewCard(
                  threats: threat.activeThreats,
                  onViewAll: () => Navigator.pushNamed(context, '/security/threats'),
                ),
                
                SizedBox(height: 16),
                
                // 学习进度
                LearningProgressCard(
                  progress: security.learningProgress,
                  onContinue: () => Navigator.pushNamed(context, '/security/education'),
                ),
              ],
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showQuickActions(),
        child: Icon(Icons.security),
        tooltip: '快速安全操作',
      ),
    );
  }

  Future<void> _refreshData() async {
    await Future.wait([
      securityProvider.refresh(),
      threatProvider.refresh(),
    ]);
  }

  Future<void> _performQuickScan() async {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => QuickScanDialog(),
    );
    
    try {
      final result = await securityProvider.performQuickScan();
      Navigator.of(context).pop();
      
      _showScanResults(result);
    } catch (error) {
      Navigator.of(context).pop();
      _showError('扫描失败: $error');
    }
  }

  void _checkThreats() {
    Navigator.pushNamed(context, '/security/threats');
  }

  void _showNotifications() {
    showModalBottomSheet(
      context: context,
      builder: (context) => SecurityNotificationsSheet(),
    );
  }

  void _showQuickActions() {
    showModalBottomSheet(
      context: context,
      builder: (context) => QuickActionsSheet(
        onQuickScan: _performQuickScan,
        onThreatCheck: _checkThreats,
        onEmergencyMode: () => securityProvider.enableEmergencyMode(),
      ),
    );
  }

  void _showScanResults(ScanResult result) {
    showDialog(
      context: context,
      builder: (context) => ScanResultDialog(result: result),
    );
  }

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }
}
```

**原生平台集成**:
```dart
// mobile-apps/shared/lib/services/native_security_service.dart
class NativeSecurityService {
  static const MethodChannel _channel = MethodChannel('security/native');

  // Android特定功能
  static Future<Map<String, dynamic>> getAndroidSecurityInfo() async {
    if (Platform.isAndroid) {
      try {
        final result = await _channel.invokeMethod('getSecurityInfo');
        return Map<String, dynamic>.from(result);
      } catch (e) {
        print('Failed to get Android security info: $e');
        return {};
      }
    }
    return {};
  }

  // iOS特定功能
  static Future<Map<String, dynamic>> getIOSSecurityInfo() async {
    if (Platform.isIOS) {
      try {
        final result = await _channel.invokeMethod('getSecurityInfo');
        return Map<String, dynamic>.from(result);
      } catch (e) {
        print('Failed to get iOS security info: $e');
        return {};
      }
    }
    return {};
  }

  // 网络扫描
  static Future<List<String>> scanLocalNetwork() async {
    try {
      final result = await _channel.invokeMethod('scanLocalNetwork');
      return List<String>.from(result);
    } catch (e) {
      print('Failed to scan local network: $e');
      return [];
    }
  }

  // 系统安全检查
  static Future<SecurityCheckResult> performSecurityCheck() async {
    try {
      final result = await _channel.invokeMethod('performSecurityCheck');
      return SecurityCheckResult.fromMap(result);
    } catch (e) {
      print('Failed to perform security check: $e');
      return SecurityCheckResult.error(e.toString());
    }
  }

  // 威胁检测
  static Future<List<ThreatAlert>> detectThreats() async {
    try {
      final result = await _channel.invokeMethod('detectThreats');
      return (result as List).map((item) => ThreatAlert.fromMap(item)).toList();
    } catch (e) {
      print('Failed to detect threats: $e');
      return [];
    }
  }
}
```

#### 3.2 Android原生实现

**Android安全模块**:
```kotlin
// mobile-apps/android/app/src/main/kotlin/SecurityModule.kt
package com.taishanglaojun.security

import android.content.Context
import android.net.ConnectivityManager
import android.net.NetworkCapabilities
import android.net.wifi.WifiManager
import android.os.Build
import androidx.annotation.RequiresApi
import io.flutter.plugin.common.MethodCall
import io.flutter.plugin.common.MethodChannel
import kotlinx.coroutines.*
import java.net.InetSocketAddress
import java.net.Socket

class SecurityModule(private val context: Context) : MethodChannel.MethodCallHandler {
    
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    override fun onMethodCall(call: MethodCall, result: MethodChannel.Result) {
        when (call.method) {
            "getSecurityInfo" -> getSecurityInfo(result)
            "scanLocalNetwork" -> scanLocalNetwork(result)
            "performSecurityCheck" -> performSecurityCheck(result)
            "detectThreats" -> detectThreats(result)
            else -> result.notImplemented()
        }
    }
    
    private fun getSecurityInfo(result: MethodChannel.Result) {
        scope.launch {
            try {
                val securityInfo = mutableMapOf<String, Any>()
                
                // 设备信息
                securityInfo["deviceModel"] = Build.MODEL
                securityInfo["androidVersion"] = Build.VERSION.RELEASE
                securityInfo["securityPatchLevel"] = Build.VERSION.SECURITY_PATCH
                
                // 网络信息
                securityInfo["networkInfo"] = getNetworkInfo()
                
                // 安全状态
                securityInfo["securityStatus"] = getSecurityStatus()
                
                withContext(Dispatchers.Main) {
                    result.success(securityInfo)
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    result.error("SECURITY_INFO_ERROR", e.message, null)
                }
            }
        }
    }
    
    private fun scanLocalNetwork(result: MethodChannel.Result) {
        scope.launch {
            try {
                val devices = mutableListOf<String>()
                val wifiManager = context.getSystemService(Context.WIFI_SERVICE) as WifiManager
                val dhcpInfo = wifiManager.dhcpInfo
                
                if (dhcpInfo != null) {
                    val gateway = dhcpInfo.gateway
                    val subnet = gateway and dhcpInfo.netmask
                    
                    // 扫描子网
                    val jobs = mutableListOf<Job>()
                    for (i in 1..254) {
                        val ip = subnet or i
                        val ipAddress = String.format(
                            "%d.%d.%d.%d",
                            ip and 0xff,
                            ip shr 8 and 0xff,
                            ip shr 16 and 0xff,
                            ip shr 24 and 0xff
                        )
                        
                        jobs.add(launch {
                            if (isHostReachable(ipAddress)) {
                                synchronized(devices) {
                                    devices.add(ipAddress)
                                }
                            }
                        })
                    }
                    
                    jobs.joinAll()
                }
                
                withContext(Dispatchers.Main) {
                    result.success(devices)
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    result.error("NETWORK_SCAN_ERROR", e.message, null)
                }
            }
        }
    }
    
    private fun performSecurityCheck(result: MethodChannel.Result) {
        scope.launch {
            try {
                val checkResult = mutableMapOf<String, Any>()
                
                // 检查root状态
                checkResult["isRooted"] = isDeviceRooted()
                
                // 检查调试状态
                checkResult["isDebuggable"] = isDebuggable()
                
                // 检查应用签名
                checkResult["signatureValid"] = isSignatureValid()
                
                // 检查网络安全
                checkResult["networkSecurity"] = checkNetworkSecurity()
                
                // 检查恶意应用
                checkResult["maliciousApps"] = detectMaliciousApps()
                
                withContext(Dispatchers.Main) {
                    result.success(checkResult)
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    result.error("SECURITY_CHECK_ERROR", e.message, null)
                }
            }
        }
    }
    
    private fun detectThreats(result: MethodChannel.Result) {
        scope.launch {
            try {
                val threats = mutableListOf<Map<String, Any>>()
                
                // 检测网络威胁
                threats.addAll(detectNetworkThreats())
                
                // 检测应用威胁
                threats.addAll(detectAppThreats())
                
                // 检测系统威胁
                threats.addAll(detectSystemThreats())
                
                withContext(Dispatchers.Main) {
                    result.success(threats)
                }
            } catch (e: Exception) {
                withContext(Dispatchers.Main) {
                    result.error("THREAT_DETECTION_ERROR", e.message, null)
                }
            }
        }
    }
    
    private suspend fun isHostReachable(host: String): Boolean {
        return withContext(Dispatchers.IO) {
            try {
                val socket = Socket()
                socket.connect(InetSocketAddress(host, 80), 1000)
                socket.close()
                true
            } catch (e: Exception) {
                false
            }
        }
    }
    
    private fun getNetworkInfo(): Map<String, Any> {
        val networkInfo = mutableMapOf<String, Any>()
        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            val network = connectivityManager.activeNetwork
            val capabilities = connectivityManager.getNetworkCapabilities(network)
            
            networkInfo["isConnected"] = capabilities != null
            networkInfo["isWifi"] = capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_WIFI) ?: false
            networkInfo["isCellular"] = capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR) ?: false
            networkInfo["isVpn"] = capabilities?.hasTransport(NetworkCapabilities.TRANSPORT_VPN) ?: false
        }
        
        return networkInfo
    }
    
    private fun getSecurityStatus(): Map<String, Any> {
        val securityStatus = mutableMapOf<String, Any>()
        
        // 检查屏幕锁定
        securityStatus["screenLockEnabled"] = isScreenLockEnabled()
        
        // 检查未知来源
        securityStatus["unknownSourcesEnabled"] = isUnknownSourcesEnabled()
        
        // 检查开发者选项
        securityStatus["developerOptionsEnabled"] = isDeveloperOptionsEnabled()
        
        return securityStatus
    }
    
    private fun isDeviceRooted(): Boolean {
        // 检查常见的root文件
        val rootPaths = arrayOf(
            "/system/app/Superuser.apk",
            "/sbin/su",
            "/system/bin/su",
            "/system/xbin/su",
            "/data/local/xbin/su",
            "/data/local/bin/su",
            "/system/sd/xbin/su",
            "/system/bin/failsafe/su",
            "/data/local/su"
        )
        
        for (path in rootPaths) {
            if (java.io.File(path).exists()) {
                return true
            }
        }
        
        return false
    }
    
    private fun isDebuggable(): Boolean {
        return (context.applicationInfo.flags and android.content.pm.ApplicationInfo.FLAG_DEBUGGABLE) != 0
    }
    
    private fun isSignatureValid(): Boolean {
        // 验证应用签名
        try {
            val packageManager = context.packageManager
            val packageInfo = packageManager.getPackageInfo(context.packageName, 
                android.content.pm.PackageManager.GET_SIGNATURES)
            
            // 这里应该验证签名是否为预期的签名
            return packageInfo.signatures.isNotEmpty()
        } catch (e: Exception) {
            return false
        }
    }
    
    private fun checkNetworkSecurity(): Map<String, Any> {
        val networkSecurity = mutableMapOf<String, Any>()
        
        // 检查网络配置
        networkSecurity["httpsOnly"] = true // 应用是否只使用HTTPS
        networkSecurity["certificatePinning"] = true // 是否启用证书固定
        
        return networkSecurity
    }
    
    private fun detectMaliciousApps(): List<String> {
        val maliciousApps = mutableListOf<String>()
        
        // 检查已安装应用的恶意特征
        val packageManager = context.packageManager
        val installedApps = packageManager.getInstalledApplications(0)
        
        for (app in installedApps) {
            if (isSuspiciousApp(app)) {
                maliciousApps.add(app.packageName)
            }
        }
        
        return maliciousApps
    }
    
    private fun detectNetworkThreats(): List<Map<String, Any>> {
        val threats = mutableListOf<Map<String, Any>>()
        
        // 检测网络威胁
        // 这里可以添加具体的网络威胁检测逻辑
        
        return threats
    }
    
    private fun detectAppThreats(): List<Map<String, Any>> {
        val threats = mutableListOf<Map<String, Any>>()
        
        // 检测应用威胁
        // 这里可以添加具体的应用威胁检测逻辑
        
        return threats
    }
    
    private fun detectSystemThreats(): List<Map<String, Any>> {
        val threats = mutableListOf<Map<String, Any>>()
        
        // 检测系统威胁
        if (isDeviceRooted()) {
            threats.add(mapOf(
                "type" to "system",
                "severity" to "high",
                "description" to "设备已被Root，存在安全风险",
                "recommendation" to "建议在非Root设备上使用"
            ))
        }
        
        return threats
    }
    
    private fun isSuspiciousApp(app: android.content.pm.ApplicationInfo): Boolean {
        // 检查应用是否可疑
        // 这里可以添加具体的检测逻辑
        return false
    }
    
    private fun isScreenLockEnabled(): Boolean {
        // 检查屏幕锁定状态
        return true // 简化实现
    }
    
    private fun isUnknownSourcesEnabled(): Boolean {
        // 检查未知来源设置
        return false // 简化实现
    }
    
    private fun isDeveloperOptionsEnabled(): Boolean {
        // 检查开发者选项
        return android.provider.Settings.Global.getInt(
            context.contentResolver,
            android.provider.Settings.Global.DEVELOPMENT_SETTINGS_ENABLED,
            0
        ) == 1
    }
}
```

#### 3.3 iOS原生实现

**iOS安全模块**:
```swift
// mobile-apps/ios/Runner/SecurityModule.swift
import Foundation
import Network
import SystemConfiguration.CaptiveNetwork
import LocalAuthentication

@objc class SecurityModule: NSObject, FlutterPlugin {
    
    static func register(with registrar: FlutterPluginRegistrar) {
        let channel = FlutterMethodChannel(name: "security/native", 
                                         binaryMessenger: registrar.messenger())
        let instance = SecurityModule()
        registrar.addMethodCallDelegate(instance, channel: channel)
    }
    
    func handle(_ call: FlutterMethodCall, result: @escaping FlutterResult) {
        switch call.method {
        case "getSecurityInfo":
            getSecurityInfo(result: result)
        case "scanLocalNetwork":
            scanLocalNetwork(result: result)
        case "performSecurityCheck":
            performSecurityCheck(result: result)
        case "detectThreats":
            detectThreats(result: result)
        default:
            result(FlutterMethodNotImplemented)
        }
    }
    
    private func getSecurityInfo(result: @escaping FlutterResult) {
        DispatchQueue.global(qos: .background).async {
            var securityInfo: [String: Any] = [:]
            
            // 设备信息
            securityInfo["deviceModel"] = UIDevice.current.model
            securityInfo["systemVersion"] = UIDevice.current.systemVersion
            securityInfo["systemName"] = UIDevice.current.systemName
            
            // 网络信息
            securityInfo["networkInfo"] = self.getNetworkInfo()
            
            // 安全状态
            securityInfo["securityStatus"] = self.getSecurityStatus()
            
            DispatchQueue.main.async {
                result(securityInfo)
            }
        }
    }
    
    private func scanLocalNetwork(result: @escaping FlutterResult) {
        DispatchQueue.global(qos: .background).async {
            var devices: [String] = []
            
            // iOS网络扫描受限，只能获取基本网络信息
            if let networkInfo = self.getCurrentNetworkInfo() {
                devices.append(networkInfo["gateway"] as? String ?? "")
            }
            
            DispatchQueue.main.async {
                result(devices)
            }
        }
    }
    
    private func performSecurityCheck(result: @escaping FlutterResult) {
        DispatchQueue.global(qos: .background).async {
            var checkResult: [String: Any] = [:]
            
            // 检查越狱状态
            checkResult["isJailbroken"] = self.isDeviceJailbroken()
            
            // 检查调试状态
            checkResult["isDebuggable"] = self.isDebuggable()
            
            // 检查生物识别
            checkResult["biometricAvailable"] = self.isBiometricAvailable()
            
            // 检查应用完整性
            checkResult["appIntegrityValid"] = self.isAppIntegrityValid()
            
            DispatchQueue.main.async {
                result(checkResult)
            }
        }
    }
    
    private func detectThreats(result: @escaping FlutterResult) {
        DispatchQueue.global(qos: .background).async {
            var threats: [[String: Any]] = []
            
            // 检测系统威胁
            threats.append(contentsOf: self.detectSystemThreats())
            
            // 检测网络威胁
            threats.append(contentsOf: self.detectNetworkThreats())
            
            DispatchQueue.main.async {
                result(threats)
            }
        }
    }
    
    private func getNetworkInfo() -> [String: Any] {
        var networkInfo: [String: Any] = [:]
        
        // 获取网络连接状态
        let reachability = SCNetworkReachabilityCreateWithName(nil, "www.apple.com")
        var flags = SCNetworkReachabilityFlags()
        
        if let reachability = reachability,
           SCNetworkReachabilityGetFlags(reachability, &flags) {
            networkInfo["isConnected"] = flags.contains(.reachable)
            networkInfo["isWiFi"] = flags.contains(.isWWAN) == false
            networkInfo["isCellular"] = flags.contains(.isWWAN)
        }
        
        return networkInfo
    }
    
    private func getSecurityStatus() -> [String: Any] {
        var securityStatus: [String: Any] = [:]
        
        // 检查设备锁定
        securityStatus["deviceLockEnabled"] = isDeviceLockEnabled()
        
        // 检查生物识别
        securityStatus["biometricEnabled"] = isBiometricEnabled()
        
        return securityStatus
    }
    
    private func isDeviceJailbroken() -> Bool {
        // 检查常见的越狱文件和路径
        let jailbreakPaths = [
            "/Applications/Cydia.app",
            "/Library/MobileSubstrate/MobileSubstrate.dylib",
            "/bin/bash",
            "/usr/sbin/sshd",
            "/etc/apt",
            "/private/var/lib/apt/",
            "/private/var/lib/cydia",
            "/private/var/mobile/Library/SBSettings/Themes",
            "/Library/MobileSubstrate/DynamicLibraries/LiveClock.plist",
            "/System/Library/LaunchDaemons/com.ikey.bbot.plist",
            "/System/Library/LaunchDaemons/com.saurik.Cydia.Startup.plist",
            "/private/var/tmp/cydia.log",
            "/private/var/lib/cydia",
            "/private/var/stash"
        ]
        
        for path in jailbreakPaths {
            if FileManager.default.fileExists(atPath: path) {
                return true
            }
        }
        
        // 检查是否可以写入系统目录
        let testPath = "/private/test_jailbreak.txt"
        do {
            try "test".write(toFile: testPath, atomically: true, encoding: .utf8)
            try FileManager.default.removeItem(atPath: testPath)
            return true
        } catch {
            // 无法写入，设备可能未越狱
        }
        
        return false
    }
    
    private func isDebuggable() -> Bool {
        // 检查是否在调试模式下运行
        #if DEBUG
        return true
        #else
        return false
        #endif
    }
    
    private func isBiometricAvailable() -> Bool {
        let context = LAContext()
        var error: NSError?
        
        return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error)
    }
    
    private func isAppIntegrityValid() -> Bool {
        // 检查应用包完整性
        guard let bundlePath = Bundle.main.bundlePath else { return false }
        
        // 检查Info.plist是否存在
        let infoPlistPath = bundlePath + "/Info.plist"
        return FileManager.default.fileExists(atPath: infoPlistPath)
    }
    
    private func detectSystemThreats() -> [[String: Any]] {
        var threats: [[String: Any]] = []
        
        if isDeviceJailbroken() {
            threats.append([
                "type": "system",
                "severity": "high",
                "description": "设备已越狱，存在安全风险",
                "recommendation": "建议在非越狱设备上使用"
            ])
        }
        
        if isDebuggable() {
            threats.append([
                "type": "app",
                "severity": "medium",
                "description": "应用运行在调试模式",
                "recommendation": "生产环境应使用发布版本"
            ])
        }
        
        return threats
    }
    
    private func detectNetworkThreats() -> [[String: Any]] {
        var threats: [[String: Any]] = []
        
        // 检测网络威胁（iOS限制较多，主要检查基本状态）
        let networkInfo = getNetworkInfo()
        if let isConnected = networkInfo["isConnected"] as? Bool, !isConnected {
            threats.append([
                "type": "network",
                "severity": "low",
                "description": "网络连接不可用",
                "recommendation": "检查网络连接"
            ])
        }
        
        return threats
    }
    
    private func getCurrentNetworkInfo() -> [String: Any]? {
        // iOS获取网络信息受限
        return nil
    }
    
    private func isDeviceLockEnabled() -> Bool {
        // 检查设备是否设置了锁屏密码
        let context = LAContext()
        var error: NSError?
        
        return context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &error)
    }
    
    private func isBiometricEnabled() -> Bool {
        return isBiometricAvailable()
    }
}
```

### 4. 手表端 - 精简实现

#### 4.1 Apple Watch实现

**WatchOS安全应用**:
```swift
// mobile-apps/watch/watchos/Sources/SecurityWatchApp.swift
import SwiftUI
import WatchKit
import WatchConnectivity

@main
struct SecurityWatchApp: App {
    @StateObject private var securityManager = WatchSecurityManager()
    
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(securityManager)
        }
    }
}

struct ContentView: View {
    @EnvironmentObject var securityManager: WatchSecurityManager
    @State private var selectedTab = 0
    
    var body: some View {
        TabView(selection: $selectedTab) {
            // 安全状态页面
            SecurityStatusView()
                .tabItem {
                    Image(systemName: "shield.fill")
                    Text("状态")
                }
                .tag(0)
            
            // 威胁告警页面
            ThreatAlertsView()
                .tabItem {
                    Image(systemName: "exclamationmark.triangle.fill")
                    Text("告警")
                }
                .tag(1)
            
            // 快速操作页面
            QuickActionsView()
                .tabItem {
                    Image(systemName: "bolt.fill")
                    Text("操作")
                }
                .tag(2)
        }
        .onAppear {
            securityManager.startMonitoring()
        }
    }
}

struct SecurityStatusView: View {
    @EnvironmentObject var securityManager: WatchSecurityManager
    
    var body: some View {
        ScrollView {
            VStack(spacing: 12) {
                // 总体安全状态
                SecurityStatusCard(
                    status: securityManager.overallStatus,
                    color: securityManager.statusColor
                )
                
                // 威胁计数
                ThreatCountCard(
                    count: securityManager.activeThreats.count,
                    severity: securityManager.highestSeverity
                )
                
                // 最后更新时间
                LastUpdateCard(
                    timestamp: securityManager.lastUpdate
                )
            }
            .padding()
        }
        .navigationTitle("安全状态")
    }
}

struct ThreatAlertsView: View {
    @EnvironmentObject var securityManager: WatchSecurityManager
    
    var body: some View {
        List {
            ForEach(securityManager.activeThreats.prefix(5), id: \.id) { threat in
                ThreatAlertRow(threat: threat)
                    .onTapGesture {
                        securityManager.acknowledgeThreat(threat.id)
                    }
            }
        }
        .navigationTitle("威胁告警")
        .overlay {
            if securityManager.activeThreats.isEmpty {
                VStack {
                    Image(systemName: "checkmark.shield.fill")
                        .font(.largeTitle)
                        .foregroundColor(.green)
                    Text("暂无威胁")
                        .font(.headline)
                }
            }
        }
    }
}

struct QuickActionsView: View {
    @EnvironmentObject var securityManager: WatchSecurityManager
    
    var body: some View {
        VStack(spacing: 16) {
            // 紧急模式
            Button(action: {
                securityManager.toggleEmergencyMode()
            }) {
                HStack {
                    Image(systemName: securityManager.isEmergencyMode ? "shield.slash.fill" : "shield.fill")
                    Text(securityManager.isEmergencyMode ? "退出紧急模式" : "紧急模式")
                }
                .foregroundColor(securityManager.isEmergencyMode ? .red : .blue)
            }
            .buttonStyle(.borderedProminent)
            
            // 快速扫描
            Button(action: {
                securityManager.performQuickScan()
            }) {
                HStack {
                    Image(systemName: "magnifyingglass")
                    Text("快速扫描")
                }
            }
            .buttonStyle(.bordered)
            .disabled(securityManager.isScanning)
            
            // 同步数据
            Button(action: {
                securityManager.syncWithPhone()
            }) {
                HStack {
                    Image(systemName: "arrow.triangle.2.circlepath")
                    Text("同步数据")
                }
            }
            .buttonStyle(.bordered)
        }
        .padding()
        .navigationTitle("快速操作")
    }
}

// 安全管理器
class WatchSecurityManager: NSObject, ObservableObject {
    @Published var overallStatus: SecurityStatus = .safe
    @Published var activeThreats: [ThreatAlert] = []
    @Published var isEmergencyMode: Bool = false
    @Published var isScanning: Bool = false
    @Published var lastUpdate: Date = Date()
    
    private var session: WCSession?
    
    var statusColor: Color {
        switch overallStatus {
        case .safe: return .green
        case .warning: return .yellow
        case .danger: return .red
        }
    }
    
    var highestSeverity: ThreatSeverity {
        return activeThreats.map(\.severity).max() ?? .low
    }
    
    override init() {
        super.init()
        setupWatchConnectivity()
    }
    
    func startMonitoring() {
        // 开始监控
        syncWithPhone()
        
        // 定期更新
        Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { _ in
            self.syncWithPhone()
        }
    }
    
    func toggleEmergencyMode() {
        isEmergencyMode.toggle()
        
        // 发送紧急模式状态到手机
        sendMessageToPhone([
            "action": "emergency_mode",
            "enabled": isEmergencyMode
        ])
        
        if isEmergencyMode {
            // 触发紧急通知
            scheduleEmergencyNotification()
        }
    }
    
    func performQuickScan() {
        guard !isScanning else { return }
        
        isScanning = true
        
        // 发送扫描请求到手机
        sendMessageToPhone([
            "action": "quick_scan"
        ])
        
        // 模拟扫描完成
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            self.isScanning = false
            self.lastUpdate = Date()
        }
    }
    
    func syncWithPhone() {
        sendMessageToPhone([
            "action": "sync_data"
        ])
    }
    
    func acknowledgeThreat(_ threatId: String) {
        activeThreats.removeAll { $0.id == threatId }
        
        sendMessageToPhone([
            "action": "acknowledge_threat",
            "threat_id": threatId
        ])
    }
    
    private func setupWatchConnectivity() {
        if WCSession.isSupported() {
            session = WCSession.default
            session?.delegate = self
            session?.activate()
        }
    }
    
    private func sendMessageToPhone(_ message: [String: Any]) {
        guard let session = session, session.isReachable else { return }
        
        session.sendMessage(message, replyHandler: { reply in
            DispatchQueue.main.async {
                self.handlePhoneReply(reply)
            }
        }, errorHandler: { error in
            print("Watch connectivity error: \(error)")
        })
    }
    
    private func handlePhoneReply(_ reply: [String: Any]) {
        if let status = reply["security_status"] as? String {
            overallStatus = SecurityStatus(rawValue: status) ?? .safe
        }
        
        if let threatsData = reply["threats"] as? [[String: Any]] {
            activeThreats = threatsData.compactMap { ThreatAlert.fromDictionary($0) }
        }
        
        lastUpdate = Date()
    }
    
    private func scheduleEmergencyNotification() {
        let content = UNMutableNotificationContent()
        content.title = "紧急模式已启用"
        content.body = "安全系统已进入紧急模式，正在加强监控"
        content.sound = .defaultCritical
        
        let request = UNNotificationRequest(
            identifier: "emergency_mode",
            content: content,
            trigger: nil
        )
        
        UNUserNotificationCenter.current().add(request)
    }
}

extension WatchSecurityManager: WCSessionDelegate {
    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
        if let error = error {
            print("Watch session activation error: \(error)")
        }
    }
    
    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
        DispatchQueue.main.async {
            self.handlePhoneReply(message)
        }
    }
}

// 数据模型
enum SecurityStatus: String, CaseIterable {
    case safe = "safe"
    case warning = "warning"
    case danger = "danger"
}

enum ThreatSeverity: String, CaseIterable, Comparable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    case critical = "critical"
    
    static func < (lhs: ThreatSeverity, rhs: ThreatSeverity) -> Bool {
        let order: [ThreatSeverity] = [.low, .medium, .high, .critical]
        return order.firstIndex(of: lhs)! < order.firstIndex(of: rhs)!
    }
}

struct ThreatAlert: Identifiable {
    let id: String
    let title: String
    let description: String
    let severity: ThreatSeverity
    let timestamp: Date
    
    static func fromDictionary(_ dict: [String: Any]) -> ThreatAlert? {
        guard let id = dict["id"] as? String,
              let title = dict["title"] as? String,
              let description = dict["description"] as? String,
              let severityString = dict["severity"] as? String,
              let severity = ThreatSeverity(rawValue: severityString),
              let timestamp = dict["timestamp"] as? TimeInterval else {
            return nil
        }
        
        return ThreatAlert(
            id: id,
            title: title,
            description: description,
            severity: severity,
            timestamp: Date(timeIntervalSince1970: timestamp)
        )
    }
}
```

#### 4.2 Wear OS实现

**Wear OS安全应用**:
```kotlin
// mobile-apps/watch/wearos/app/src/main/java/SecurityWatchApp.kt
package com.taishanglaojun.security.watch

import android.app.Application
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import androidx.wear.compose.material.*
import androidx.wear.compose.navigation.SwipeDismissableNavHost
import androidx.wear.compose.navigation.composable
import androidx.wear.compose.navigation.rememberSwipeDismissableNavController
import com.google.android.gms.wearable.*

class SecurityWatchApp : Application() {
    override fun onCreate() {
        super.onCreate()
        // 初始化Wear OS连接
        Wearable.getDataClient(this)
        Wearable.getMessageClient(this)
    }
}

@Composable
fun SecurityWatchMainScreen() {
    val navController = rememberSwipeDismissableNavController()
    val securityViewModel: SecurityWatchViewModel = viewModel()
    
    SwipeDismissableNavHost(
        navController = navController,
        startDestination = "security_status"
    ) {
        composable("security_status") {
            SecurityStatusScreen(
                viewModel = securityViewModel,
                onNavigateToThreats = { navController.navigate("threats") },
                onNavigateToActions = { navController.navigate("actions") }
            )
        }
        
        composable("threats") {
            ThreatAlertsScreen(
                viewModel = securityViewModel,
                onBack = { navController.popBackStack() }
            )
        }
        
        composable("actions") {
            QuickActionsScreen(
                viewModel = securityViewModel,
                onBack = { navController.popBackStack() }
            )
        }
    }
}

@Composable
fun SecurityStatusScreen(
    viewModel: SecurityWatchViewModel,
    onNavigateToThreats: () -> Unit,
    onNavigateToActions: () -> Unit
) {
    val securityState by viewModel.securityState.collectAsState()
    
    ScalingLazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        item {
            // 安全状态卡片
            Card(
                modifier = Modifier.fillMaxWidth(),
                backgroundColor = when (securityState.status) {
                    SecurityStatus.SAFE -> Color.Green
                    SecurityStatus.WARNING -> Color.Yellow
                    SecurityStatus.DANGER -> Color.Red
                }
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.Security,
                        contentDescription = "Security Status",
                        modifier = Modifier.size(32.dp)
                    )
                    Text(
                        text = when (securityState.status) {
                            SecurityStatus.SAFE -> "安全"
                            SecurityStatus.WARNING -> "警告"
                            SecurityStatus.DANGER -> "危险"
                        },
                        style = MaterialTheme.typography.h6
                    )
                }
            }
        }
        
        item {
            // 威胁计数
            Chip(
                modifier = Modifier.fillMaxWidth(),
                onClick = onNavigateToThreats,
                label = {
                    Text("威胁: ${securityState.threatCount}")
                },
                icon = {
                    Icon(
                        imageVector = Icons.Default.Warning,
                        contentDescription = "Threats"
                    )
                }
            )
        }
        
        item {
            // 快速操作
            Chip(
                modifier = Modifier.fillMaxWidth(),
                onClick = onNavigateToActions,
                label = {
                    Text("快速操作")
                },
                icon = {
                    Icon(
                        imageVector = Icons.Default.FlashOn,
                        contentDescription = "Quick Actions"
                    )
                }
            )
        }
    }
}

@Composable
fun ThreatAlertsScreen(
    viewModel: SecurityWatchViewModel,
    onBack: () -> Unit
) {
    val threats by viewModel.threats.collectAsState()
    
    ScalingLazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp)
    ) {
        items(threats.take(5)) { threat ->
            ThreatAlertCard(
                threat = threat,
                onAcknowledge = { viewModel.acknowledgeThreat(threat.id) }
            )
        }
        
        if (threats.isEmpty()) {
            item {
                Column(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalAlignment = Alignment.CenterHorizontally
                ) {
                    Icon(
                        imageVector = Icons.Default.CheckCircle,
                        contentDescription = "No Threats",
                        modifier = Modifier.size(48.dp),
                        tint = Color.Green
                    )
                    Text("暂无威胁")
                }
            }
        }
    }
}

@Composable
fun QuickActionsScreen(
    viewModel: SecurityWatchViewModel,
    onBack: () -> Unit
) {
    val isEmergencyMode by viewModel.isEmergencyMode.collectAsState()
    val isScanning by viewModel.isScanning.collectAsState()
    
    ScalingLazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        item {
            // 紧急模式
            Chip(
                modifier = Modifier.fillMaxWidth(),
                onClick = { viewModel.toggleEmergencyMode() },
                label = {
                    Text(if (isEmergencyMode) "退出紧急模式" else "紧急模式")
                },
                icon = {
                    Icon(
                        imageVector = if (isEmergencyMode) Icons.Default.Shield else Icons.Default.Security,
                        contentDescription = "Emergency Mode"
                    )
                },
                colors = ChipDefaults.chipColors(
                    backgroundColor = if (isEmergencyMode) Color.Red else Color.Blue
                )
            )
        }
        
        item {
            // 快速扫描
            Chip(
                modifier = Modifier.fillMaxWidth(),
                onClick = { viewModel.performQuickScan() },
                enabled = !isScanning,
                label = {
                    Text(if (isScanning) "扫描中..." else "快速扫描")
                },
                icon = {
                    Icon(
                        imageVector = Icons.Default.Search,
                        contentDescription = "Quick Scan"
                    )
                }
            )
        }
        
        item {
            // 同步数据
            Chip(
                modifier = Modifier.fillMaxWidth(),
                onClick = { viewModel.syncWithPhone() },
                label = {
                    Text("同步数据")
                },
                icon = {
                    Icon(
                        imageVector = Icons.Default.Sync,
                        contentDescription = "Sync Data"
                    )
                }
            )
        }
    }
}

@Composable
fun ThreatAlertCard(
    threat: ThreatAlert,
    onAcknowledge: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        onClick = onAcknowledge
    ) {
        Column(
            modifier = Modifier.padding(12.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = threat.title,
                    style = MaterialTheme.typography.body1,
                    modifier = Modifier.weight(1f)
                )
                
                Icon(
                    imageVector = when (threat.severity) {
                        ThreatSeverity.LOW -> Icons.Default.Info
                        ThreatSeverity.MEDIUM -> Icons.Default.Warning
                        ThreatSeverity.HIGH -> Icons.Default.Error
                        ThreatSeverity.CRITICAL -> Icons.Default.Dangerous
                    },
                    contentDescription = "Severity",
                    tint = when (threat.severity) {
                        ThreatSeverity.LOW -> Color.Blue
                        ThreatSeverity.MEDIUM -> Color.Yellow
                        ThreatSeverity.HIGH -> Color.Red
                        ThreatSeverity.CRITICAL -> Color.Magenta
                    }
                )
            }
            
            Text(
                text = threat.description,
                style = MaterialTheme.typography.body2,
                maxLines = 2
            )
        }
    }
}
```

## 🚀 统一部署策略

### 1. 容器化部署架构

**Docker Compose配置**:
```yaml
# deployment/docker-compose.security.yml
version: '3.8'

services:
  # API网关
  api-gateway:
    build: 
      context: ./backend/api-gateway
      dockerfile: Dockerfile.security
    ports:
      - "8080:8080"
    environment:
      - SECURITY_MODULE_ENABLED=true
      - JWT_SECRET=${JWT_SECRET}
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
      - postgres
    networks:
      - security-network

  # 安全服务
  pentest-service:
    build: ./backend/services/pentest
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/pentest_db
      - REDIS_URL=redis://redis:6379
      - RABBITMQ_URL=amqp://rabbitmq:5672
    depends_on:
      - postgres
      - redis
      - rabbitmq
    networks:
      - security-network
    cap_add:
      - NET_RAW
      - NET_ADMIN

  threat-detection-service:
    build: ./backend/services/threat-detection
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/threat_db
      - MONGODB_URL=mongodb://mongodb:27017/threat_logs
      - KAFKA_BROKERS=kafka:9092
    depends_on:
      - postgres
      - mongodb
      - kafka
    networks:
      - security-network

  security-education-service:
    build: ./backend/services/security-education
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/education_db
      - NEO4J_URL=bolt://neo4j:7687
    depends_on:
      - postgres
      - neo4j
    networks:
      - security-network

  # Web前端
  web-security-frontend:
    build: 
      context: ./frontend/web-app
      dockerfile: Dockerfile.security
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_URL=http://api-gateway:8080
      - REACT_APP_SECURITY_ENABLED=true
    depends_on:
      - api-gateway
    networks:
      - security-network

  # 数据库
  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=taishanglaojun
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init-security.sql:/docker-entrypoint-initdb.d/init-security.sql
    networks:
      - security-network

  mongodb:
    image: mongo:6.0
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
    volumes:
      - mongodb_data:/data/db
    networks:
      - security-network

  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - security-network

  neo4j:
    image: neo4j:5.0
    environment:
      - NEO4J_AUTH=neo4j/${NEO4J_PASSWORD}
      - NEO4J_PLUGINS=["apoc"]
    volumes:
      - neo4j_data:/data
    networks:
      - security-network

  # 消息队列
  rabbitmq:
    image: rabbitmq:3.11-management-alpine
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq
    networks:
      - security-network

  kafka:
    image: confluentinc/cp-kafka:latest
    environment:
      - KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:9092
      - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
    depends_on:
      - zookeeper
    networks:
      - security-network

  zookeeper:
    image: confluentinc/cp-zookeeper:latest
    environment:
      - ZOOKEEPER_CLIENT_PORT=2181
      - ZOOKEEPER_TICK_TIME=2000
    networks:
      - security-network

volumes:
  postgres_data:
  mongodb_data:
  redis_data:
  neo4j_data:
  rabbitmq_data:

networks:
  security-network:
    driver: bridge
```

### 2. Kubernetes部署配置

**Kubernetes部署清单**:
```yaml
# deployment/k8s/security-namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: taishanglaojun-security
  labels:
    name: security
    environment: production

---
# deployment/k8s/security-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: security-config
  namespace: taishanglaojun-security
data:
  API_GATEWAY_URL: "http://api-gateway-service:8080"
  SECURITY_MODULE_ENABLED: "true"
  LOG_LEVEL: "info"
  METRICS_ENABLED: "true"

---
# deployment/k8s/security-secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: security-secrets
  namespace: taishanglaojun-security
type: Opaque
data:
  jwt-secret: <base64-encoded-jwt-secret>
  postgres-password: <base64-encoded-postgres-password>
  redis-password: <base64-encoded-redis-password>
  mongodb-password: <base64-encoded-mongodb-password>

---
# deployment/k8s/pentest-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pentest-service
  namespace: taishanglaojun-security
spec:
  replicas: 3
  selector:
    matchLabels:
      app: pentest-service
  template:
    metadata:
      labels:
        app: pentest-service
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
      containers:
      - name: pentest-service
        image: taishanglaojun/pentest-service:latest
        ports:
        - containerPort: 8081
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: security-secrets
              key: database-url
        - name: REDIS_URL
          valueFrom:
            configMapKeyRef:
              name: security-config
              key: REDIS_URL
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            add:
            - NET_RAW
            drop:
            - ALL
          readOnlyRootFilesystem: true
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8081
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8081
          initialDelaySeconds: 5
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: pentest-service
  namespace: taishanglaojun-security
spec:
  selector:
    app: pentest-service
  ports:
  - protocol: TCP
    port: 8081
    targetPort: 8081
  type: ClusterIP

---
# deployment/k8s/web-security-frontend.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-security-frontend
  namespace: taishanglaojun-security
spec:
  replicas: 2
  selector:
    matchLabels:
      app: web-security-frontend
  template:
    metadata:
      labels:
        app: web-security-frontend
    spec:
      containers:
      - name: web-security-frontend
        image: taishanglaojun/web-security-frontend:latest
        ports:
        - containerPort: 3000
        env:
        - name: REACT_APP_API_URL
          valueFrom:
            configMapKeyRef:
              name: security-config
              key: API_GATEWAY_URL
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"

---
apiVersion: v1
kind: Service
metadata:
  name: web-security-frontend-service
  namespace: taishanglaojun-security
spec:
  selector:
    app: web-security-frontend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3000
  type: LoadBalancer

---
# deployment/k8s/network-policy.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: security-network-policy
  namespace: taishanglaojun-security
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: taishanglaojun-security
    ports:
    - protocol: TCP
      port: 8080
    - protocol: TCP
      port: 8081
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: taishanglaojun-security
    ports:
    - protocol: TCP
      port: 5432
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 27017
```

### 3. 移动应用发布策略

**移动应用CI/CD流水线**:
```yaml
# .github/workflows/mobile-security-deploy.yml
name: Mobile Security App Deployment

on:
  push:
    branches: [main]
    paths: ['mobile-apps/**']
  pull_request:
    branches: [main]
    paths: ['mobile-apps/**']

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.16.0'
    
    - name: Install dependencies
      run: |
        cd mobile-apps/shared
        flutter pub get
    
    - name: Run tests
      run: |
        cd mobile-apps/shared
        flutter test
    
    - name: Run security analysis
      run: |
        cd mobile-apps/shared
        flutter analyze
        dart run dart_code_metrics:metrics analyze lib

  build-android:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.16.0'
    
    - name: Setup Android SDK
      uses: android-actions/setup-android@v2
    
    - name: Build Android APK
      run: |
        cd mobile-apps/android
        flutter build apk --release --split-per-abi
    
    - name: Build Android App Bundle
      run: |
        cd mobile-apps/android
        flutter build appbundle --release
    
    - name: Sign Android App
      uses: r0adkll/sign-android-release@v1
      with:
        releaseDirectory: mobile-apps/android/build/app/outputs/bundle/release
        signingKeyBase64: ${{ secrets.ANDROID_SIGNING_KEY }}
        alias: ${{ secrets.ANDROID_KEY_ALIAS }}
        keyStorePassword: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        keyPassword: ${{ secrets.ANDROID_KEY_PASSWORD }}
    
    - name: Upload to Google Play
      uses: r0adkll/upload-google-play@v1
      with:
        serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT }}
        packageName: com.taishanglaojun.security
        releaseFiles: mobile-apps/android/build/app/outputs/bundle/release/*.aab
        track: internal

  build-ios:
    needs: test
    runs-on: macos-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.16.0'
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Install CocoaPods
      run: sudo gem install cocoapods
    
    - name: Build iOS
      run: |
        cd mobile-apps/ios
        flutter build ios --release --no-codesign
    
    - name: Build and Archive
      run: |
        cd mobile-apps/ios
        xcodebuild -workspace Runner.xcworkspace \
                   -scheme Runner \
                   -configuration Release \
                   -destination generic/platform=iOS \
                   -archivePath build/Runner.xcarchive \
                   archive
    
    - name: Export IPA
      run: |
        cd mobile-apps/ios
        xcodebuild -exportArchive \
                   -archivePath build/Runner.xcarchive \
                   -exportPath build \
                   -exportOptionsPlist ExportOptions.plist
    
    - name: Upload to App Store
      uses: apple-actions/upload-testflight-build@v1
      with:
        app-path: mobile-apps/ios/build/Runner.ipa
        issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
        api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}
        api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}

  build-desktop:
    needs: test
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.16.0'
    
    - name: Enable desktop support
      run: |
        flutter config --enable-linux-desktop
        flutter config --enable-windows-desktop
        flutter config --enable-macos-desktop
    
    - name: Build desktop app
      run: |
        cd desktop-apps/flutter
        flutter pub get
        if [ "$RUNNER_OS" == "Linux" ]; then
          flutter build linux --release
        elif [ "$RUNNER_OS" == "Windows" ]; then
          flutter build windows --release
        elif [ "$RUNNER_OS" == "macOS" ]; then
          flutter build macos --release
        fi
      shell: bash
    
    - name: Package desktop app
      run: |
        cd desktop-apps/flutter
        if [ "$RUNNER_OS" == "Linux" ]; then
          tar -czf taishanglaojun-security-linux.tar.gz -C build/linux/x64/release/bundle .
        elif [ "$RUNNER_OS" == "Windows" ]; then
          7z a taishanglaojun-security-windows.zip ./build/windows/runner/Release/*
        elif [ "$RUNNER_OS" == "macOS" ]; then
          hdiutil create -volname "TaiShangLaoJun Security" -srcfolder build/macos/Build/Products/Release/taishanglaojun_security.app -ov -format UDZO taishanglaojun-security-macos.dmg
        fi
      shell: bash
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: desktop-${{ matrix.os }}
        path: |
          desktop-apps/flutter/*.tar.gz
          desktop-apps/flutter/*.zip
          desktop-apps/flutter/*.dmg
```

## 📊 性能监控和运维

### 监控配置

**Prometheus配置**:
```yaml
# monitoring/prometheus-security.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  - "security_rules.yml"

scrape_configs:
  - job_name: 'security-services'
    static_configs:
      - targets: 
        - 'pentest-service:8081'
        - 'threat-detection-service:8082'
        - 'security-education-service:8083'
    metrics_path: /metrics
    scrape_interval: 10s

  - job_name: 'security-frontend'
    static_configs:
      - targets: ['web-security-frontend:3000']
    metrics_path: /metrics

alerting:
  alertmanagers:
    - static_configs:
        - targets:
          - alertmanager:9093

# monitoring/security_rules.yml
groups:
  - name: security_alerts
    rules:
    - alert: HighThreatDetection
      expr: threat_detection_rate > 10
      for: 1m
      labels:
        severity: critical
      annotations:
        summary: "高威胁检测率"
        description: "威胁检测率超过阈值: {{ $value }}"

    - alert: PentestServiceDown
      expr: up{job="pentest-service"} == 0
      for: 30s
      labels:
        severity: critical
      annotations:
        summary: "渗透测试服务不可用"
        description: "渗透测试服务已停止响应"

    - alert: SecurityScanFailure
      expr: security_scan_failure_rate > 0.1
      for: 2m
      labels:
        severity: warning
      annotations:
        summary: "安全扫描失败率过高"
        description: "安全扫描失败率: {{ $value }}"
```

## 🎯 总结

本多端安全功能集成方案为太上老君AI平台提供了完整的跨平台安全解决方案：

### 核心特性
1. **统一架构**: 基于微服务的统一后端API，支持所有终端平台
2. **功能分层**: 根据设备能力提供不同层级的安全功能
3. **实时同步**: 跨设备的安全状态和数据实时同步
4. **原生集成**: 深度集成各平台原生安全能力

### 技术优势
1. **高性能**: 原生模块处理性能关键任务
2. **高安全**: 多层安全防护和合规设计
3. **高可用**: 容器化部署和自动扩缩容
4. **易维护**: 统一的CI/CD流水线和监控体系

### 商业价值
1. **市场覆盖**: 全平台覆盖，最大化用户触达
2. **用户体验**: 一致的跨平台体验
3. **技术领先**: 创新的多端安全架构
4. **生态完整**: 完整的安全教育和实践生态

这个方案确保了太上老君AI平台的安全功能能够在所有主流平台上提供一致、高效、安全的用户体验。
```