import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { frontendMenuService, type UserPermissions } from '../services/frontendMenuService';
import { type MenuItem as FrontendMenuItem } from '../config/menuConfig';
import i18n from '../i18n';

interface MenuContextType {
  menuItems: FrontendMenuItem[];
  loading: boolean;
  error: string | null;
  loadMenuData: (userPermissions?: UserPermissions) => Promise<void>;
  refreshMenu: () => Promise<void>;
  clearMenu: () => void;
}

const MenuContext = createContext<MenuContextType | null>(null);

interface MenuProviderProps {
  children: React.ReactNode;
}

export const MenuProvider: React.FC<MenuProviderProps> = ({ children }) => {
  // ‰ªÖÂ≠òÂÇ®ÂèØÂ∫èÂàóÂåñÁöÑËèúÂçïÂ≠óÊÆµÔºåÈÅøÂÖç React ÂÖÉÁ¥†Âú®Êú¨Âú∞Â≠òÂÇ®‰∏≠ÂØºËá¥ÈîôËØØ
  const sanitizeMenuItems = (items: any[]): any[] => {
    return (items || []).map(item => {
      const { icon, children, ...rest } = item || {};
      const sanitized: any = { ...rest };
      // ÂéªÈô§‰∏çÂèØÂ∫èÂàóÂåñÁöÑ React ÂÖÉÁ¥†
      sanitized.icon = undefined;
      if (Array.isArray(children) && children.length > 0) {
        sanitized.children = sanitizeMenuItems(children);
      }
      return sanitized;
    });
  };

  const [menuItems, setMenuItems] = useState<FrontendMenuItem[]>(() => {
    // ‰ªélocalStorageÊÅ¢Â§çËèúÂçïÁä∂ÊÄÅÔºàÊ∏ÖÁêÜÂõæÊ†áÁ≠â‰∏çÂèØÂ∫èÂàóÂåñÂ≠óÊÆµÔºâ
    try {
      const savedMenuItems = localStorage.getItem('menuItems');
      if (!savedMenuItems) return [];
      const parsed = JSON.parse(savedMenuItems);
      // Èò≤Âæ°ÔºöÂ¶ÇÊûúËß£ÊûêÂà∞ÁöÑ icon ÊòØÂØπË±°ÔºàÂèØËÉΩÊòØ‰∏çÂêàÊ≥ïÁöÑ React ÂÖÉÁ¥†Âø´ÁÖßÔºâÔºåËøõË°åÊ∏ÖÁêÜ
      const cleaned = sanitizeMenuItems(parsed);
      // È¢ùÂ§ñÊ∏ÖÊ¥óÔºöËã• label ÁúãËµ∑Êù•ÊòØÈîÆÂêçÔºàmainMenu.labels.*ÔºâÔºåÂõûÈÄÄ‰∏∫ÈîÆÂ∞æÊÆµ
      const normalizeLabels = (items: any[]): any[] => items.map(it => {
        const next: any = { ...it };
        const lk = next.labelKey as string | undefined;
        const lbl = next.label as string | undefined;
        const looksLikeKey = typeof lbl === 'string' && lbl.startsWith('mainMenu.labels.');
        if (lk && (looksLikeKey || !lbl)) {
          next.label = lk.startsWith('mainMenu.labels.') ? (lk.split('.').pop() || lk) : (lbl || lk);
        }
        if (Array.isArray(next.children)) {
          next.children = normalizeLabels(next.children);
        }
        return next;
      });
      return normalizeLabels(cleaned);
    } catch (error) {
      console.warn('Failed to load menu items from localStorage:', error);
      // Âá∫ÈîôÊó∂Ê∏ÖÈô§ÊçüÂùèÁöÑÁºìÂ≠ò
      try { localStorage.removeItem('menuItems'); } catch {}
      return [];
    }
  });
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Ëá™Âä®‰øùÂ≠òËèúÂçïÁä∂ÊÄÅÂà∞localStorageÔºà‰ªÖ‰øùÂ≠òÂèØÂ∫èÂàóÂåñÂ≠óÊÆµÔºâ
  useEffect(() => {
    if (menuItems.length > 0) {
      try {
        const serializable = sanitizeMenuItems(menuItems as any);
        localStorage.setItem('menuItems', JSON.stringify(serializable));
      } catch (error) {
        console.warn('Failed to save menu items to localStorage:', error);
      }
    }
  }, [menuItems]);
  const [lastUserPermissions, setLastUserPermissions] = useState<UserPermissions | null>(null);

  const loadMenuData = useCallback(async (userPermissions?: UserPermissions) => {
    // Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõÁî®Êà∑ÊùÉÈôêÔºå‰∏î‰πãÂâçÊ≤°ÊúâÂä†ËΩΩËøáÔºåÂàô‰∏çÊâßË°å
    if (!userPermissions && !lastUserPermissions) {
      return;
    }

    const permissionsToUse = userPermissions || lastUserPermissions;
    if (!permissionsToUse) {
      return;
    }

    try {
      setLoading(true);
      setError(null);
      
      console.log('üîÑ MenuContext: ÂºÄÂßãÂä†ËΩΩËèúÂçïÊï∞ÊçÆ...', permissionsToUse);
      
      const menus = await frontendMenuService.getMainMenu(permissionsToUse);
      
      console.log('‚úÖ MenuContext: ËèúÂçïÊï∞ÊçÆÂä†ËΩΩÊàêÂäü', menus.length, '‰∏™ËèúÂçï');
      
      setMenuItems(menus);
      setLastUserPermissions(permissionsToUse);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Âä†ËΩΩËèúÂçïÂ§±Ë¥•';
      console.error('‚ùå MenuContext: ËèúÂçïÊï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•', errorMessage);
      setError(errorMessage);
      setMenuItems([]);
    } finally {
      setLoading(false);
    }
  }, []); // ÁßªÈô§lastUserPermissions‰æùËµñÔºåÈÅøÂÖçÊó†ÈôêÂæ™ÁéØ

  const refreshMenu = useCallback(async () => {
    if (lastUserPermissions) {
      console.log('üîÑ MenuContext: Âà∑Êñ∞ËèúÂçïÊï∞ÊçÆ...');
      // Ê∏ÖÈô§ÁºìÂ≠òÂπ∂ÈáçÊñ∞Âä†ËΩΩ
      frontendMenuService.clearCache();
      await loadMenuData(lastUserPermissions);
    }
  }, [loadMenuData]); // Âè™‰øùÁïôloadMenuData‰æùËµñ

  const clearMenu = useCallback(() => {
    console.log('üóëÔ∏è MenuContext: Ê∏ÖÈô§ËèúÂçïÊï∞ÊçÆ');
    setMenuItems([]);
    setError(null);
    setLoading(false);
    setLastUserPermissions(null);
    frontendMenuService.clearCache();
    // ÂêåÊó∂Ê∏ÖÈô§localStorage‰∏≠ÁöÑËèúÂçïÊï∞ÊçÆ
    try {
      localStorage.removeItem('menuItems');
    } catch (error) {
      console.warn('Failed to clear menu items from localStorage:', error);
    }
  }, []);

  // ÁõëÂê¨ËØ≠Ë®ÄÂàáÊç¢ÔºåÊ∏ÖÁêÜÁºìÂ≠òÂπ∂Âà∑Êñ∞ËèúÂçïÔºå‰ª•Á°Æ‰øù labelKey ÁîüÊïà
  useEffect(() => {
    const handleLanguageChange = () => {
      try { localStorage.removeItem('menuItems'); } catch {}
      frontendMenuService.clearCache();
      // ‰ΩøÁî®ÊúÄËøë‰∏ÄÊ¨°ÊùÉÈôê‰∏ä‰∏ãÊñáÂà∑Êñ∞ËèúÂçï
      if (lastUserPermissions) {
        loadMenuData(lastUserPermissions).catch(() => {});
      } else {
        refreshMenu().catch(() => {});
      }
    };
    i18n.on('languageChanged', handleLanguageChange);
    return () => {
      i18n.off('languageChanged', handleLanguageChange);
    };
  }, [lastUserPermissions, loadMenuData, refreshMenu]);

  const contextValue: MenuContextType = {
    menuItems,
    loading,
    error,
    loadMenuData,
    refreshMenu,
    clearMenu,
  };

  return (
    <MenuContext.Provider value={contextValue}>
      {children}
    </MenuContext.Provider>
  );
};

export const useMenu = (): MenuContextType => {
  const context = useContext(MenuContext);
  if (!context) {
    throw new Error('useMenu must be used within a MenuProvider');
  }
  return context;
};

export default MenuContext;